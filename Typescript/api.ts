// tslint:disable
/**
 * BITFLEX Public API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApplicationUser
 */
export interface ApplicationUser {
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    isGoogleAuthenticatorEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    googleAuthenticatorSecretKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    pinCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    lastIPAccess?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationUser
     */
    lastDateAccess?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    isChatDisabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApplicationUser
     */
    makerFee?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationUser
     */
    takerFee?: number | null;
    /**
     * 
     * @type {UserCategory}
     * @memberof ApplicationUser
     */
    category?: UserCategory;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    isGoogleSignInAllowed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    isFacebookSignInAllowed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    affiliateUserId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationUser
     */
    registrationDateTime?: number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    userName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    normalizedUserName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    normalizedEmail?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    emailConfirmed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    passwordHash?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    securityStamp?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    concurrencyStamp?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    phoneNumber?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    phoneNumberConfirmed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    twoFactorEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    lockoutEnd?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    lockoutEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApplicationUser
     */
    accessFailedCount?: number;
}
/**
 * 
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * 
     * @type {string}
     * @memberof Balance
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Balance
     */
    currencyId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof Balance
     */
    userId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Balance
     */
    concurrencyStamp?: string | null;
}
/**
 * 
 * @export
 * @interface BalanceAction
 */
export interface BalanceAction {
    /**
     * 
     * @type {string}
     * @memberof BalanceAction
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BalanceAction
     */
    currencyId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BalanceAction
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof BalanceAction
     */
    userId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BalanceAction
     */
    dateTime?: number;
    /**
     * 
     * @type {string}
     * @memberof BalanceAction
     */
    reasonText?: string | null;
    /**
     * 
     * @type {BalanceActionType}
     * @memberof BalanceAction
     */
    type?: BalanceActionType;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum BalanceActionType {
    Deposit = 'Deposit',
    Withdraw = 'Withdraw'
}

/**
 * 
 * @export
 * @interface BitcoinBasedCurrency
 */
export interface BitcoinBasedCurrency {
    /**
     * 
     * @type {string}
     * @memberof BitcoinBasedCurrency
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BitcoinBasedCurrency
     */
    currencyId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BitcoinBasedCurrency
     */
    rpcIp?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BitcoinBasedCurrency
     */
    rpcPort?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BitcoinBasedCurrency
     */
    rpcUsername?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BitcoinBasedCurrency
     */
    rpcPassword?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CascadeTiming {
    NUMBER_0 = 0,
    NUMBER_1 = 1,
    NUMBER_2 = 2
}

/**
 * 
 * @export
 * @interface ChangeTracker
 */
export interface ChangeTracker {
    /**
     * 
     * @type {boolean}
     * @memberof ChangeTracker
     */
    autoDetectChangesEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChangeTracker
     */
    lazyLoadingEnabled?: boolean;
    /**
     * 
     * @type {QueryTrackingBehavior}
     * @memberof ChangeTracker
     */
    queryTrackingBehavior?: QueryTrackingBehavior;
    /**
     * 
     * @type {CascadeTiming}
     * @memberof ChangeTracker
     */
    deleteOrphansTiming?: CascadeTiming;
    /**
     * 
     * @type {CascadeTiming}
     * @memberof ChangeTracker
     */
    cascadeDeleteTiming?: CascadeTiming;
    /**
     * 
     * @type {DbContext}
     * @memberof ChangeTracker
     */
    context?: DbContext;
}
/**
 * 
 * @export
 * @interface CryptoCurrency
 */
export interface CryptoCurrency {
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrency
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrency
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrency
     */
    shortName?: string | null;
    /**
     * 
     * @type {Type}
     * @memberof CryptoCurrency
     */
    currencyType?: Type;
    /**
     * 
     * @type {boolean}
     * @memberof CryptoCurrency
     */
    active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CryptoCurrency
     */
    depositDisabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CryptoCurrency
     */
    withdrawDisabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    coinMarketCapId?: number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    coinMarketCapUsdPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    coinMarketCapLastUpdate?: number;
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrency
     */
    image?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CryptoCurrency
     */
    isMarketCurrency?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrency
     */
    blockExplolerTxIdUrl?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    withdrawCurrencyFee?: number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    withdrawPercentFee?: number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    confirmationCount?: number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    minimumTradeAmount?: number;
}
/**
 * 
 * @export
 * @interface DatabaseFacade
 */
export interface DatabaseFacade {
    /**
     * 
     * @type {IDbContextTransaction}
     * @memberof DatabaseFacade
     */
    currentTransaction?: IDbContextTransaction;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseFacade
     */
    autoTransactionsEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DatabaseFacade
     */
    providerName?: string | null;
}
/**
 * 
 * @export
 * @interface DbContext
 */
export interface DbContext {
    /**
     * 
     * @type {DatabaseFacade}
     * @memberof DbContext
     */
    database?: DatabaseFacade;
    /**
     * 
     * @type {ChangeTracker}
     * @memberof DbContext
     */
    changeTracker?: ChangeTracker;
    /**
     * 
     * @type {object}
     * @memberof DbContext
     */
    model?: object;
    /**
     * 
     * @type {DbContextId}
     * @memberof DbContext
     */
    contextId?: DbContextId;
}
/**
 * 
 * @export
 * @interface DbContextId
 */
export interface DbContextId {
    /**
     * 
     * @type {string}
     * @memberof DbContextId
     */
    instanceId?: string;
    /**
     * 
     * @type {number}
     * @memberof DbContextId
     */
    lease?: number;
}
/**
 * 
 * @export
 * @interface DepositAddress
 */
export interface DepositAddress {
    /**
     * 
     * @type {string}
     * @memberof DepositAddress
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DepositAddress
     */
    userId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DepositAddress
     */
    currencyId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DepositAddress
     */
    address?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DepositAddress
     */
    account?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DepositAddress
     */
    requireTokenCollect?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DepositAddress
     */
    isEthForReturnSent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DepositAddress
     */
    privateKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DepositAddress
     */
    depositTag?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DeviceType {
    IOS = 'iOS',
    Android = 'Android',
    Chrome = 'Chrome',
    Safari = 'Safari'
}

/**
 * 
 * @export
 * @interface ERC20Token
 */
export interface ERC20Token {
    /**
     * 
     * @type {string}
     * @memberof ERC20Token
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ERC20Token
     */
    currencyId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ERC20Token
     */
    contractAddress?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ERC20Token
     */
    decimals?: number;
    /**
     * 
     * @type {number}
     * @memberof ERC20Token
     */
    tokenBlockNumber?: number;
}
/**
 * 
 * @export
 * @interface EnableDisable2Fa
 */
export interface EnableDisable2Fa {
    /**
     * 
     * @type {string}
     * @memberof EnableDisable2Fa
     */
    clientCode: string;
    /**
     * 
     * @type {string}
     * @memberof EnableDisable2Fa
     */
    pincode: string;
}
/**
 * 
 * @export
 * @interface ForgotPassword
 */
export interface ForgotPassword {
    /**
     * 
     * @type {string}
     * @memberof ForgotPassword
     */
    email: string;
}
/**
 * 
 * @export
 * @interface IApplicationQrCommand
 */
export interface IApplicationQrCommand {
    /**
     * 
     * @type {string}
     * @memberof IApplicationQrCommand
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IApplicationQrCommand
     */
    userId?: string | null;
    /**
     * 
     * @type {QrCommand}
     * @memberof IApplicationQrCommand
     */
    qrCommand?: QrCommand;
    /**
     * 
     * @type {number}
     * @memberof IApplicationQrCommand
     */
    executed?: number;
}
/**
 * 
 * @export
 * @interface IApplicationTokenAccess
 */
export interface IApplicationTokenAccess {
    /**
     * 
     * @type {string}
     * @memberof IApplicationTokenAccess
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IApplicationTokenAccess
     */
    userId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IApplicationTokenAccess
     */
    tokenString?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IApplicationTokenAccess
     */
    deviceDescription?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IApplicationTokenAccess
     */
    devicePushToken?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IApplicationTokenAccess
     */
    expiry?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IApplicationTokenAccess
     */
    valid?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IApplicationTokenAccess
     */
    deviceId?: string | null;
}
/**
 * 
 * @export
 * @interface IDbContextTransaction
 */
export interface IDbContextTransaction {
    /**
     * 
     * @type {string}
     * @memberof IDbContextTransaction
     */
    transactionId?: string;
}
/**
 * 
 * @export
 * @interface IdentityRole
 */
export interface IdentityRole {
    /**
     * 
     * @type {string}
     * @memberof IdentityRole
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityRole
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityRole
     */
    normalizedName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityRole
     */
    concurrencyStamp?: string | null;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    ContentType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    ContentDisposition?: string | null;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof InlineObject
     */
    Headers?: { [key: string]: Array<string>; } | null;
    /**
     * 
     * @type {number}
     * @memberof InlineObject
     */
    Length?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    FileName?: string | null;
}
/**
 * 
 * @export
 * @interface KeyValue
 */
export interface KeyValue {
    /**
     * 
     * @type {string}
     * @memberof KeyValue
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KeyValue
     */
    key?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KeyValue
     */
    value?: string | null;
}
/**
 * 
 * @export
 * @interface ManualWithdrawRequest
 */
export interface ManualWithdrawRequest {
    /**
     * 
     * @type {string}
     * @memberof ManualWithdrawRequest
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ManualWithdrawRequest
     */
    currencyId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ManualWithdrawRequest
     */
    userId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ManualWithdrawRequest
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof ManualWithdrawRequest
     */
    dateCreated?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ManualWithdrawRequest
     */
    paid?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ManualWithdrawRequest
     */
    datePaid?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ManualWithdrawRequest
     */
    information?: string | null;
}
/**
 * 
 * @export
 * @interface Market
 */
export interface Market {
    /**
     * 
     * @type {string}
     * @memberof Market
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Market
     */
    currencyId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Market
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    userId?: string | null;
    /**
     * 
     * @type {TradeType}
     * @memberof Order
     */
    tradeType?: TradeType;
    /**
     * 
     * @type {OrderTypes}
     * @memberof Order
     */
    orderType?: OrderTypes;
    /**
     * 
     * @type {OrderState}
     * @memberof Order
     */
    orderState?: OrderState;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    tradePairId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    amountLeft?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    totalLeft?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    stopLossPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    takeProfitPrice?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    isMargin?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    liquidationPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    initialPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    leverage?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    initialAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    pairCurrencyId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    marketCurrencyId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    dateCreated?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    dateClosed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    dateOnMarket?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    closed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    concurrencyStamp?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OrderState {
    WaitingForActivation = 'WaitingForActivation',
    OnMarket = 'OnMarket',
    PartiallyFilled = 'PartiallyFilled',
    Cancelled = 'Cancelled',
    Rejected = 'Rejected',
    CloseFilled = 'Close_Filled',
    CancelledByUser = 'Cancelled_ByUser',
    CloseMarginCall = 'Close_MarginCall'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum OrderTypes {
    Market = 'Market',
    Limit = 'Limit',
    StopLossLimit = 'StopLossLimit',
    TakeProfitLimit = 'TakeProfitLimit',
    StopLossMarket = 'StopLossMarket',
    OCO = 'OCO'
}

/**
 * 
 * @export
 * @interface PostCancelOrderRequest
 */
export interface PostCancelOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof PostCancelOrderRequest
     */
    id?: string | null;
}
/**
 * 
 * @export
 * @interface PostGetReferrerEmailRequest
 */
export interface PostGetReferrerEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof PostGetReferrerEmailRequest
     */
    refId?: string | null;
}
/**
 * 
 * @export
 * @interface PostOrdersRequest
 */
export interface PostOrdersRequest {
    /**
     * 
     * @type {number}
     * @memberof PostOrdersRequest
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof PostOrdersRequest
     */
    price?: number;
    /**
     * 
     * @type {TradeType}
     * @memberof PostOrdersRequest
     */
    tradeType?: TradeType;
    /**
     * 
     * @type {string}
     * @memberof PostOrdersRequest
     */
    pairId?: string | null;
    /**
     * 
     * @type {OrderTypes}
     * @memberof PostOrdersRequest
     */
    orderType?: OrderTypes;
    /**
     * 
     * @type {number}
     * @memberof PostOrdersRequest
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface PostSendSms
 */
export interface PostSendSms {
    /**
     * 
     * @type {string}
     * @memberof PostSendSms
     */
    phoneNumber: string;
}
/**
 * 
 * @export
 * @interface PostSetAffiliateRequest
 */
export interface PostSetAffiliateRequest {
    /**
     * 
     * @type {string}
     * @memberof PostSetAffiliateRequest
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PostSetAffiliateRequest
     */
    userId?: string | null;
}
/**
 * 
 * @export
 * @interface PostVefirySms
 */
export interface PostVefirySms {
    /**
     * 
     * @type {string}
     * @memberof PostVefirySms
     */
    phoneNumber: string;
    /**
     * 
     * @type {string}
     * @memberof PostVefirySms
     */
    code: string;
}
/**
 * 
 * @export
 * @interface PostWithdrawRequest
 */
export interface PostWithdrawRequest {
    /**
     * 
     * @type {number}
     * @memberof PostWithdrawRequest
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof PostWithdrawRequest
     */
    address?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PostWithdrawRequest
     */
    pinCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PostWithdrawRequest
     */
    destinationTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PostWithdrawRequest
     */
    twoFactorCode?: string | null;
}
/**
 * 
 * @export
 * @interface PushToken
 */
export interface PushToken {
    /**
     * 
     * @type {string}
     * @memberof PushToken
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PushToken
     */
    userId?: string | null;
    /**
     * 
     * @type {DeviceType}
     * @memberof PushToken
     */
    device?: DeviceType;
    /**
     * 
     * @type {string}
     * @memberof PushToken
     */
    deviceId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PushToken
     */
    token?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PushToken
     */
    description?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum QrCommand {
    TFAEnable = 'TFAEnable',
    TFADisable = 'TFADisable',
    SignIn = 'SignIn',
    WithdrawalConfirmation = 'WithdrawalConfirmation'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum QueryTrackingBehavior {
    NUMBER_0 = 0,
    NUMBER_1 = 1
}

/**
 * 
 * @export
 * @interface Quote
 */
export interface Quote {
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    pairId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    timestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    open?: number;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    high?: number;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    low?: number;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    close?: number;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    volume?: number;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    pairVolume?: number;
}
/**
 * 
 * @export
 * @interface ResetPassword
 */
export interface ResetPassword {
    /**
     * 
     * @type {string}
     * @memberof ResetPassword
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof ResetPassword
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof ResetPassword
     */
    code?: string | null;
}
/**
 * 
 * @export
 * @interface RippleDestinationTag
 */
export interface RippleDestinationTag {
    /**
     * 
     * @type {string}
     * @memberof RippleDestinationTag
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RippleDestinationTag
     */
    userId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RippleDestinationTag
     */
    destinationTag?: number;
}
/**
 * 
 * @export
 * @interface SignIn
 */
export interface SignIn {
    /**
     * 
     * @type {string}
     * @memberof SignIn
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SignIn
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof SignIn
     */
    code?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SignIn
     */
    oauth?: boolean;
}
/**
 * 
 * @export
 * @interface SignUp
 */
export interface SignUp {
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    pinCode: string;
    /**
     * 
     * @type {boolean}
     * @memberof SignUp
     */
    isInApp?: boolean;
}
/**
 * 
 * @export
 * @interface SmsVerificationMessage
 */
export interface SmsVerificationMessage {
    /**
     * 
     * @type {string}
     * @memberof SmsVerificationMessage
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmsVerificationMessage
     */
    userId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmsVerificationMessage
     */
    phoneNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmsVerificationMessage
     */
    code?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SmsVerificationMessage
     */
    lastSendTime?: number;
}
/**
 * 
 * @export
 * @interface StringIdentityRoleClaim
 */
export interface StringIdentityRoleClaim {
    /**
     * 
     * @type {number}
     * @memberof StringIdentityRoleClaim
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof StringIdentityRoleClaim
     */
    roleId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StringIdentityRoleClaim
     */
    claimType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StringIdentityRoleClaim
     */
    claimValue?: string | null;
}
/**
 * 
 * @export
 * @interface StringIdentityUserClaim
 */
export interface StringIdentityUserClaim {
    /**
     * 
     * @type {number}
     * @memberof StringIdentityUserClaim
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof StringIdentityUserClaim
     */
    userId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StringIdentityUserClaim
     */
    claimType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StringIdentityUserClaim
     */
    claimValue?: string | null;
}
/**
 * 
 * @export
 * @interface StringIdentityUserLogin
 */
export interface StringIdentityUserLogin {
    /**
     * 
     * @type {string}
     * @memberof StringIdentityUserLogin
     */
    loginProvider?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StringIdentityUserLogin
     */
    providerKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StringIdentityUserLogin
     */
    providerDisplayName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StringIdentityUserLogin
     */
    userId?: string | null;
}
/**
 * 
 * @export
 * @interface StringIdentityUserRole
 */
export interface StringIdentityUserRole {
    /**
     * 
     * @type {string}
     * @memberof StringIdentityUserRole
     */
    userId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StringIdentityUserRole
     */
    roleId?: string | null;
}
/**
 * 
 * @export
 * @interface StringIdentityUserToken
 */
export interface StringIdentityUserToken {
    /**
     * 
     * @type {string}
     * @memberof StringIdentityUserToken
     */
    userId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StringIdentityUserToken
     */
    loginProvider?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StringIdentityUserToken
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StringIdentityUserToken
     */
    value?: string | null;
}
/**
 * 
 * @export
 * @interface Trade
 */
export interface Trade {
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    pairId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    makerOrderId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    takerOrderId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    transactionDate?: number;
    /**
     * 
     * @type {TradeType}
     * @memberof Trade
     */
    tradeType?: TradeType;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TradeType {
    Buy = 'Buy',
    Sell = 'Sell'
}

/**
 * 
 * @export
 * @interface TradingAmount
 */
export interface TradingAmount {
    /**
     * 
     * @type {string}
     * @memberof TradingAmount
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TradingAmount
     */
    userId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TradingAmount
     */
    totalBtc?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TradingAmount
     */
    monthBtc?: number;
    /**
     * 
     * @type {number}
     * @memberof TradingAmount
     */
    promoPeriodBtc?: number;
}
/**
 * 
 * @export
 * @interface TradingPair
 */
export interface TradingPair {
    /**
     * 
     * @type {string}
     * @memberof TradingPair
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TradingPair
     */
    marketId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TradingPair
     */
    currencyId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TradingPair
     */
    pairCompleteName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TradingPair
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TradingPair
     */
    minimumTradeAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof TradingPair
     */
    order?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TradingPair
     */
    leverage?: number;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    userId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    txId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    currencyId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    date?: number;
    /**
     * 
     * @type {TransactionDirection}
     * @memberof Transaction
     */
    direction?: TransactionDirection;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    done?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TransactionDirection {
    In = 'In',
    Out = 'Out'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Type {
    BtcBased = 'BtcBased',
    EthBased = 'EthBased',
    Fiat = 'Fiat',
    Ripple = 'Ripple',
    Eos = 'Eos',
    ERC20 = 'ERC20'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum UserCategory {
    Standart = 'Standart',
    Privileged = 'Privileged',
    Premium = 'Premium'
}

/**
 * 
 * @export
 * @interface WithdrawRequest
 */
export interface WithdrawRequest {
    /**
     * 
     * @type {string}
     * @memberof WithdrawRequest
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WithdrawRequest
     */
    currencyId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WithdrawRequest
     */
    userId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WithdrawRequest
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof WithdrawRequest
     */
    dateCreated?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WithdrawRequest
     */
    paid?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WithdrawRequest
     */
    datePaid?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WithdrawRequest
     */
    txId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WithdrawRequest
     */
    destinationAddress?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WithdrawRequest
     */
    destinationTag?: string | null;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminAddcointokenPost: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Admin/addcointoken`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAdminAddcointokenPost(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).apiAdminAddcointokenPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminAddcointokenPost(body?: object, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).apiAdminAddcointokenPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiAdminAddcointokenPost(body?: object, options?: any) {
        return AdminApiFp(this.configuration).apiAdminAddcointokenPost(body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BalanceApi - axios parameter creator
 * @export
 */
export const BalanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceCurrencyGet: async (currency: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling balanceCurrencyGet.');
            }
            const localVarPath = `/Balance/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceDepositCurrencyAddressGet: async (currency: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling balanceDepositCurrencyAddressGet.');
            }
            const localVarPath = `/Balance/deposit/{currency}/address`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceDepositCurrencyAddressPost: async (currency: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling balanceDepositCurrencyAddressPost.');
            }
            const localVarPath = `/Balance/deposit/{currency}/address`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceRoute: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Balance`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceWithdrawCurrencyPageGet: async (currency: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling balanceWithdrawCurrencyPageGet.');
            }
            const localVarPath = `/Balance/withdraw/{currency}/page`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {PostWithdrawRequest} [postWithdrawRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceWithdrawCurrencyPost: async (currency: string, postWithdrawRequest?: PostWithdrawRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling balanceWithdrawCurrencyPost.');
            }
            const localVarPath = `/Balance/withdraw/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof postWithdrawRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postWithdrawRequest !== undefined ? postWithdrawRequest : {}) : (postWithdrawRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalanceApi - functional programming interface
 * @export
 */
export const BalanceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balanceCurrencyGet(currency: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BalanceApiAxiosParamCreator(configuration).balanceCurrencyGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balanceDepositCurrencyAddressGet(currency: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BalanceApiAxiosParamCreator(configuration).balanceDepositCurrencyAddressGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balanceDepositCurrencyAddressPost(currency: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BalanceApiAxiosParamCreator(configuration).balanceDepositCurrencyAddressPost(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balanceRoute(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BalanceApiAxiosParamCreator(configuration).balanceRoute(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balanceWithdrawCurrencyPageGet(currency: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BalanceApiAxiosParamCreator(configuration).balanceWithdrawCurrencyPageGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {PostWithdrawRequest} [postWithdrawRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balanceWithdrawCurrencyPost(currency: string, postWithdrawRequest?: PostWithdrawRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BalanceApiAxiosParamCreator(configuration).balanceWithdrawCurrencyPost(currency, postWithdrawRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BalanceApi - factory interface
 * @export
 */
export const BalanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceCurrencyGet(currency: string, options?: any): AxiosPromise<void> {
            return BalanceApiFp(configuration).balanceCurrencyGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceDepositCurrencyAddressGet(currency: string, options?: any): AxiosPromise<void> {
            return BalanceApiFp(configuration).balanceDepositCurrencyAddressGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceDepositCurrencyAddressPost(currency: string, options?: any): AxiosPromise<void> {
            return BalanceApiFp(configuration).balanceDepositCurrencyAddressPost(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceRoute(options?: any): AxiosPromise<void> {
            return BalanceApiFp(configuration).balanceRoute(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceWithdrawCurrencyPageGet(currency: string, options?: any): AxiosPromise<void> {
            return BalanceApiFp(configuration).balanceWithdrawCurrencyPageGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} currency 
         * @param {PostWithdrawRequest} [postWithdrawRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceWithdrawCurrencyPost(currency: string, postWithdrawRequest?: PostWithdrawRequest, options?: any): AxiosPromise<void> {
            return BalanceApiFp(configuration).balanceWithdrawCurrencyPost(currency, postWithdrawRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalanceApi - object-oriented interface
 * @export
 * @class BalanceApi
 * @extends {BaseAPI}
 */
export class BalanceApi extends BaseAPI {
    /**
     * 
     * @param {string} currency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public balanceCurrencyGet(currency: string, options?: any) {
        return BalanceApiFp(this.configuration).balanceCurrencyGet(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} currency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public balanceDepositCurrencyAddressGet(currency: string, options?: any) {
        return BalanceApiFp(this.configuration).balanceDepositCurrencyAddressGet(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} currency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public balanceDepositCurrencyAddressPost(currency: string, options?: any) {
        return BalanceApiFp(this.configuration).balanceDepositCurrencyAddressPost(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public balanceRoute(options?: any) {
        return BalanceApiFp(this.configuration).balanceRoute(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} currency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public balanceWithdrawCurrencyPageGet(currency: string, options?: any) {
        return BalanceApiFp(this.configuration).balanceWithdrawCurrencyPageGet(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} currency 
     * @param {PostWithdrawRequest} [postWithdrawRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public balanceWithdrawCurrencyPost(currency: string, postWithdrawRequest?: PostWithdrawRequest, options?: any) {
        return BalanceApiFp(this.configuration).balanceWithdrawCurrencyPost(currency, postWithdrawRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CognitiveApi - axios parameter creator
 * @export
 */
export const CognitiveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [contentType] 
         * @param {string} [contentDisposition] 
         * @param {number} [length] 
         * @param {string} [name] 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cognitiveSavefilePost: async (contentType?: string, contentDisposition?: string, length?: number, name?: string, fileName?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Cognitive/savefile`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


            if (contentType !== undefined) { 
                localVarFormParams.append('ContentType', contentType as any);
            }
    
            if (contentDisposition !== undefined) { 
                localVarFormParams.append('ContentDisposition', contentDisposition as any);
            }
    
            if (length !== undefined) { 
                localVarFormParams.append('Length', length as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('Name', name as any);
            }
    
            if (fileName !== undefined) { 
                localVarFormParams.append('FileName', fileName as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cognitiveVerifyfacesPost: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Cognitive/verifyfaces`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CognitiveApi - functional programming interface
 * @export
 */
export const CognitiveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [contentType] 
         * @param {string} [contentDisposition] 
         * @param {number} [length] 
         * @param {string} [name] 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cognitiveSavefilePost(contentType?: string, contentDisposition?: string, length?: number, name?: string, fileName?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CognitiveApiAxiosParamCreator(configuration).cognitiveSavefilePost(contentType, contentDisposition, length, name, fileName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cognitiveVerifyfacesPost(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CognitiveApiAxiosParamCreator(configuration).cognitiveVerifyfacesPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CognitiveApi - factory interface
 * @export
 */
export const CognitiveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [contentType] 
         * @param {string} [contentDisposition] 
         * @param {number} [length] 
         * @param {string} [name] 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cognitiveSavefilePost(contentType?: string, contentDisposition?: string, length?: number, name?: string, fileName?: string, options?: any): AxiosPromise<string> {
            return CognitiveApiFp(configuration).cognitiveSavefilePost(contentType, contentDisposition, length, name, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cognitiveVerifyfacesPost(body?: object, options?: any): AxiosPromise<string> {
            return CognitiveApiFp(configuration).cognitiveVerifyfacesPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CognitiveApi - object-oriented interface
 * @export
 * @class CognitiveApi
 * @extends {BaseAPI}
 */
export class CognitiveApi extends BaseAPI {
    /**
     * 
     * @param {string} [contentType] 
     * @param {string} [contentDisposition] 
     * @param {number} [length] 
     * @param {string} [name] 
     * @param {string} [fileName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CognitiveApi
     */
    public cognitiveSavefilePost(contentType?: string, contentDisposition?: string, length?: number, name?: string, fileName?: string, options?: any) {
        return CognitiveApiFp(this.configuration).cognitiveSavefilePost(contentType, contentDisposition, length, name, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CognitiveApi
     */
    public cognitiveVerifyfacesPost(body?: object, options?: any) {
        return CognitiveApiFp(this.configuration).cognitiveVerifyfacesPost(body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * MarketsApi - axios parameter creator
 * @export
 */
export const MarketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsCurrenciesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Markets/currencies`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [fingerprint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsGet: async (fingerprint?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Markets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsHistoryGet: async (pair?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Markets/history`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsOrderbookGet: async (pair?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Markets/orderbook`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsTickersGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Markets/tickers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketsApi - functional programming interface
 * @export
 */
export const MarketsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMarketsCurrenciesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await MarketsApiAxiosParamCreator(configuration).apiMarketsCurrenciesGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [fingerprint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMarketsGet(fingerprint?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await MarketsApiAxiosParamCreator(configuration).apiMarketsGet(fingerprint, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMarketsHistoryGet(pair?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await MarketsApiAxiosParamCreator(configuration).apiMarketsHistoryGet(pair, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMarketsOrderbookGet(pair?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await MarketsApiAxiosParamCreator(configuration).apiMarketsOrderbookGet(pair, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMarketsTickersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await MarketsApiAxiosParamCreator(configuration).apiMarketsTickersGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MarketsApi - factory interface
 * @export
 */
export const MarketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsCurrenciesGet(options?: any): AxiosPromise<Array<object>> {
            return MarketsApiFp(configuration).apiMarketsCurrenciesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [fingerprint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsGet(fingerprint?: string, options?: any): AxiosPromise<object> {
            return MarketsApiFp(configuration).apiMarketsGet(fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsHistoryGet(pair?: string, options?: any): AxiosPromise<Array<object>> {
            return MarketsApiFp(configuration).apiMarketsHistoryGet(pair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsOrderbookGet(pair?: string, options?: any): AxiosPromise<void> {
            return MarketsApiFp(configuration).apiMarketsOrderbookGet(pair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsTickersGet(options?: any): AxiosPromise<object> {
            return MarketsApiFp(configuration).apiMarketsTickersGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketsApi - object-oriented interface
 * @export
 * @class MarketsApi
 * @extends {BaseAPI}
 */
export class MarketsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketsApi
     */
    public apiMarketsCurrenciesGet(options?: any) {
        return MarketsApiFp(this.configuration).apiMarketsCurrenciesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [fingerprint] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketsApi
     */
    public apiMarketsGet(fingerprint?: string, options?: any) {
        return MarketsApiFp(this.configuration).apiMarketsGet(fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [pair] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketsApi
     */
    public apiMarketsHistoryGet(pair?: string, options?: any) {
        return MarketsApiFp(this.configuration).apiMarketsHistoryGet(pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [pair] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketsApi
     */
    public apiMarketsOrderbookGet(pair?: string, options?: any) {
        return MarketsApiFp(this.configuration).apiMarketsOrderbookGet(pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketsApi
     */
    public apiMarketsTickersGet(options?: any) {
        return MarketsApiFp(this.configuration).apiMarketsTickersGet(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostCancelOrderRequest} [postCancelOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersCancelPost: async (postCancelOrderRequest?: PostCancelOrderRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Orders/cancel`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof postCancelOrderRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postCancelOrderRequest !== undefined ? postCancelOrderRequest : {}) : (postCancelOrderRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} pairName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPairNameGet: async (pairName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pairName' is not null or undefined
            if (pairName === null || pairName === undefined) {
                throw new RequiredError('pairName','Required parameter pairName was null or undefined when calling ordersPairNameGet.');
            }
            const localVarPath = `/Orders/{pairName}`
                .replace(`{${"pairName"}}`, encodeURIComponent(String(pairName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostOrdersRequest} [postOrdersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPost: async (postOrdersRequest?: PostOrdersRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Orders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof postOrdersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postOrdersRequest !== undefined ? postOrdersRequest : {}) : (postOrdersRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostCancelOrderRequest} [postCancelOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersCancelPost(postCancelOrderRequest?: PostCancelOrderRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).ordersCancelPost(postCancelOrderRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} pairName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersPairNameGet(pairName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).ordersPairNameGet(pairName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostOrdersRequest} [postOrdersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersPost(postOrdersRequest?: PostOrdersRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).ordersPost(postOrdersRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {PostCancelOrderRequest} [postCancelOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersCancelPost(postCancelOrderRequest?: PostCancelOrderRequest, options?: any): AxiosPromise<void> {
            return OrdersApiFp(configuration).ordersCancelPost(postCancelOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} pairName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPairNameGet(pairName: string, options?: any): AxiosPromise<void> {
            return OrdersApiFp(configuration).ordersPairNameGet(pairName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostOrdersRequest} [postOrdersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPost(postOrdersRequest?: PostOrdersRequest, options?: any): AxiosPromise<void> {
            return OrdersApiFp(configuration).ordersPost(postOrdersRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * 
     * @param {PostCancelOrderRequest} [postCancelOrderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersCancelPost(postCancelOrderRequest?: PostCancelOrderRequest, options?: any) {
        return OrdersApiFp(this.configuration).ordersCancelPost(postCancelOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} pairName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersPairNameGet(pairName: string, options?: any) {
        return OrdersApiFp(this.configuration).ordersPairNameGet(pairName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostOrdersRequest} [postOrdersRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersPost(postOrdersRequest?: PostOrdersRequest, options?: any) {
        return OrdersApiFp(this.configuration).ordersPost(postOrdersRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StaticPagesApi - axios parameter creator
 * @export
 */
export const StaticPagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staticPagesAffiliateGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/StaticPages/affiliate`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staticPagesStatusGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/StaticPages/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StaticPagesApi - functional programming interface
 * @export
 */
export const StaticPagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staticPagesAffiliateGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StaticPagesApiAxiosParamCreator(configuration).staticPagesAffiliateGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staticPagesStatusGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StaticPagesApiAxiosParamCreator(configuration).staticPagesStatusGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StaticPagesApi - factory interface
 * @export
 */
export const StaticPagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staticPagesAffiliateGet(options?: any): AxiosPromise<void> {
            return StaticPagesApiFp(configuration).staticPagesAffiliateGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staticPagesStatusGet(options?: any): AxiosPromise<void> {
            return StaticPagesApiFp(configuration).staticPagesStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StaticPagesApi - object-oriented interface
 * @export
 * @class StaticPagesApi
 * @extends {BaseAPI}
 */
export class StaticPagesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaticPagesApi
     */
    public staticPagesAffiliateGet(options?: any) {
        return StaticPagesApiFp(this.configuration).staticPagesAffiliateGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaticPagesApi
     */
    public staticPagesStatusGet(options?: any) {
        return StaticPagesApiFp(this.configuration).staticPagesStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TradingViewUdfApi - axios parameter creator
 * @export
 */
export const TradingViewUdfApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTradingViewUdfConfigGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/TradingViewUdf/config`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [from] 
         * @param {number} [to] 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTradingViewUdfHistoryGet: async (from?: number, to?: number, symbol?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/TradingViewUdf/history`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTradingViewUdfSymbolsGet: async (symbol?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/TradingViewUdf/symbols`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTradingViewUdfTimeGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/TradingViewUdf/time`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradingViewUdfApi - functional programming interface
 * @export
 */
export const TradingViewUdfApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTradingViewUdfConfigGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TradingViewUdfApiAxiosParamCreator(configuration).apiTradingViewUdfConfigGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [from] 
         * @param {number} [to] 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTradingViewUdfHistoryGet(from?: number, to?: number, symbol?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TradingViewUdfApiAxiosParamCreator(configuration).apiTradingViewUdfHistoryGet(from, to, symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTradingViewUdfSymbolsGet(symbol?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TradingViewUdfApiAxiosParamCreator(configuration).apiTradingViewUdfSymbolsGet(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTradingViewUdfTimeGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TradingViewUdfApiAxiosParamCreator(configuration).apiTradingViewUdfTimeGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TradingViewUdfApi - factory interface
 * @export
 */
export const TradingViewUdfApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTradingViewUdfConfigGet(options?: any): AxiosPromise<void> {
            return TradingViewUdfApiFp(configuration).apiTradingViewUdfConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [from] 
         * @param {number} [to] 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTradingViewUdfHistoryGet(from?: number, to?: number, symbol?: string, options?: any): AxiosPromise<void> {
            return TradingViewUdfApiFp(configuration).apiTradingViewUdfHistoryGet(from, to, symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTradingViewUdfSymbolsGet(symbol?: string, options?: any): AxiosPromise<void> {
            return TradingViewUdfApiFp(configuration).apiTradingViewUdfSymbolsGet(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTradingViewUdfTimeGet(options?: any): AxiosPromise<void> {
            return TradingViewUdfApiFp(configuration).apiTradingViewUdfTimeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradingViewUdfApi - object-oriented interface
 * @export
 * @class TradingViewUdfApi
 * @extends {BaseAPI}
 */
export class TradingViewUdfApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingViewUdfApi
     */
    public apiTradingViewUdfConfigGet(options?: any) {
        return TradingViewUdfApiFp(this.configuration).apiTradingViewUdfConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [from] 
     * @param {number} [to] 
     * @param {string} [symbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingViewUdfApi
     */
    public apiTradingViewUdfHistoryGet(from?: number, to?: number, symbol?: string, options?: any) {
        return TradingViewUdfApiFp(this.configuration).apiTradingViewUdfHistoryGet(from, to, symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [symbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingViewUdfApi
     */
    public apiTradingViewUdfSymbolsGet(symbol?: string, options?: any) {
        return TradingViewUdfApiFp(this.configuration).apiTradingViewUdfSymbolsGet(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingViewUdfApi
     */
    public apiTradingViewUdfTimeGet(options?: any) {
        return TradingViewUdfApiFp(this.configuration).apiTradingViewUdfTimeGet(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserBalanceactionsGet: async (page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/balanceactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserBalancesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/balances`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserBalanceslistGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/balanceslist`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserDepositsGet: async (currency?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/deposits`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGetapptokenGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/getapptoken`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserOrdersGet: async (pair?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/orders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTradehistoryGet: async (page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/tradehistory`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserValidateOauthGet: async (id?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/validateOauth`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserValidateapptokenPost: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/validateapptoken`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserWithdrawalsGet: async (currency?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/withdrawals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        user2faPost: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/2fa`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<CryptoCurrency>} [cryptoCurrencies] 
         * @param {Array<Order>} [orders] 
         * @param {Array<DepositAddress>} [depositAddresses] 
         * @param {Array<Balance>} [userBalances] 
         * @param {Array<Market>} [markets] 
         * @param {Array<TradingPair>} [tradingPairs] 
         * @param {Array<Transaction>} [transactions] 
         * @param {Array<WithdrawRequest>} [withdrawRequests] 
         * @param {Array<ManualWithdrawRequest>} [manualWithdrawRequests] 
         * @param {Array<Trade>} [trades] 
         * @param {Array<Quote>} [quotes] 
         * @param {Array<SmsVerificationMessage>} [smsVerificationMessages] 
         * @param {Array<TradingAmount>} [tradingAmounts] 
         * @param {Array<RippleDestinationTag>} [rippleDestinationTags] 
         * @param {Array<BitcoinBasedCurrency>} [bitcoinBasedCurrencies] 
         * @param {Array<ERC20Token>} [eRC20Tokens] 
         * @param {Array<BalanceAction>} [balanceActions] 
         * @param {Array<KeyValue>} [keysValues] 
         * @param {Array<IApplicationTokenAccess>} [applicationTokenAccesses] 
         * @param {Array<IApplicationQrCommand>} [applicationQrCommands] 
         * @param {Array<PushToken>} [pushTokens] 
         * @param {Array<StringIdentityUserRole>} [userRoles] 
         * @param {Array<IdentityRole>} [roles] 
         * @param {Array<StringIdentityRoleClaim>} [roleClaims] 
         * @param {Array<ApplicationUser>} [users] 
         * @param {Array<StringIdentityUserClaim>} [userClaims] 
         * @param {Array<StringIdentityUserLogin>} [userLogins] 
         * @param {Array<StringIdentityUserToken>} [userTokens] 
         * @param {string} [databaseCurrentTransactionTransactionId] 
         * @param {boolean} [databaseAutoTransactionsEnabled] 
         * @param {string} [databaseProviderName] 
         * @param {boolean} [changeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerCascadeDeleteTiming] 
         * @param {string} [changeTrackerContextDatabaseCurrentTransactionTransactionId] 
         * @param {boolean} [changeTrackerContextDatabaseAutoTransactionsEnabled] 
         * @param {string} [changeTrackerContextDatabaseProviderName] 
         * @param {boolean} [changeTrackerContextChangeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerContextChangeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerContextChangeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerCascadeDeleteTiming] 
         * @param {DbContext} [changeTrackerContextChangeTrackerContext] 
         * @param {object} [changeTrackerContextModel] 
         * @param {string} [changeTrackerContextContextIdInstanceId] 
         * @param {number} [changeTrackerContextContextIdLease] 
         * @param {object} [model] 
         * @param {string} [contextIdInstanceId] 
         * @param {number} [contextIdLease] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAffiliatedataPost: async (cryptoCurrencies?: Array<CryptoCurrency>, orders?: Array<Order>, depositAddresses?: Array<DepositAddress>, userBalances?: Array<Balance>, markets?: Array<Market>, tradingPairs?: Array<TradingPair>, transactions?: Array<Transaction>, withdrawRequests?: Array<WithdrawRequest>, manualWithdrawRequests?: Array<ManualWithdrawRequest>, trades?: Array<Trade>, quotes?: Array<Quote>, smsVerificationMessages?: Array<SmsVerificationMessage>, tradingAmounts?: Array<TradingAmount>, rippleDestinationTags?: Array<RippleDestinationTag>, bitcoinBasedCurrencies?: Array<BitcoinBasedCurrency>, eRC20Tokens?: Array<ERC20Token>, balanceActions?: Array<BalanceAction>, keysValues?: Array<KeyValue>, applicationTokenAccesses?: Array<IApplicationTokenAccess>, applicationQrCommands?: Array<IApplicationQrCommand>, pushTokens?: Array<PushToken>, userRoles?: Array<StringIdentityUserRole>, roles?: Array<IdentityRole>, roleClaims?: Array<StringIdentityRoleClaim>, users?: Array<ApplicationUser>, userClaims?: Array<StringIdentityUserClaim>, userLogins?: Array<StringIdentityUserLogin>, userTokens?: Array<StringIdentityUserToken>, databaseCurrentTransactionTransactionId?: string, databaseAutoTransactionsEnabled?: boolean, databaseProviderName?: string, changeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerLazyLoadingEnabled?: boolean, changeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId?: string, changeTrackerContextDatabaseAutoTransactionsEnabled?: boolean, changeTrackerContextDatabaseProviderName?: string, changeTrackerContextChangeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerContextChangeTrackerLazyLoadingEnabled?: boolean, changeTrackerContextChangeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextChangeTrackerContext?: DbContext, changeTrackerContextModel?: object, changeTrackerContextContextIdInstanceId?: string, changeTrackerContextContextIdLease?: number, model?: object, contextIdInstanceId?: string, contextIdLease?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/affiliatedata`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (cryptoCurrencies) {
                localVarQueryParameter['CryptoCurrencies'] = cryptoCurrencies;
            }

            if (orders) {
                localVarQueryParameter['Orders'] = orders;
            }

            if (depositAddresses) {
                localVarQueryParameter['DepositAddresses'] = depositAddresses;
            }

            if (userBalances) {
                localVarQueryParameter['UserBalances'] = userBalances;
            }

            if (markets) {
                localVarQueryParameter['Markets'] = markets;
            }

            if (tradingPairs) {
                localVarQueryParameter['TradingPairs'] = tradingPairs;
            }

            if (transactions) {
                localVarQueryParameter['Transactions'] = transactions;
            }

            if (withdrawRequests) {
                localVarQueryParameter['WithdrawRequests'] = withdrawRequests;
            }

            if (manualWithdrawRequests) {
                localVarQueryParameter['ManualWithdrawRequests'] = manualWithdrawRequests;
            }

            if (trades) {
                localVarQueryParameter['Trades'] = trades;
            }

            if (quotes) {
                localVarQueryParameter['Quotes'] = quotes;
            }

            if (smsVerificationMessages) {
                localVarQueryParameter['SmsVerificationMessages'] = smsVerificationMessages;
            }

            if (tradingAmounts) {
                localVarQueryParameter['TradingAmounts'] = tradingAmounts;
            }

            if (rippleDestinationTags) {
                localVarQueryParameter['RippleDestinationTags'] = rippleDestinationTags;
            }

            if (bitcoinBasedCurrencies) {
                localVarQueryParameter['BitcoinBasedCurrencies'] = bitcoinBasedCurrencies;
            }

            if (eRC20Tokens) {
                localVarQueryParameter['ERC20Tokens'] = eRC20Tokens;
            }

            if (balanceActions) {
                localVarQueryParameter['BalanceActions'] = balanceActions;
            }

            if (keysValues) {
                localVarQueryParameter['KeysValues'] = keysValues;
            }

            if (applicationTokenAccesses) {
                localVarQueryParameter['ApplicationTokenAccesses'] = applicationTokenAccesses;
            }

            if (applicationQrCommands) {
                localVarQueryParameter['ApplicationQrCommands'] = applicationQrCommands;
            }

            if (pushTokens) {
                localVarQueryParameter['PushTokens'] = pushTokens;
            }

            if (userRoles) {
                localVarQueryParameter['UserRoles'] = userRoles;
            }

            if (roles) {
                localVarQueryParameter['Roles'] = roles;
            }

            if (roleClaims) {
                localVarQueryParameter['RoleClaims'] = roleClaims;
            }

            if (users) {
                localVarQueryParameter['Users'] = users;
            }

            if (userClaims) {
                localVarQueryParameter['UserClaims'] = userClaims;
            }

            if (userLogins) {
                localVarQueryParameter['UserLogins'] = userLogins;
            }

            if (userTokens) {
                localVarQueryParameter['UserTokens'] = userTokens;
            }

            if (databaseCurrentTransactionTransactionId !== undefined) {
                localVarQueryParameter['Database.CurrentTransaction.TransactionId'] = databaseCurrentTransactionTransactionId;
            }

            if (databaseAutoTransactionsEnabled !== undefined) {
                localVarQueryParameter['Database.AutoTransactionsEnabled'] = databaseAutoTransactionsEnabled;
            }

            if (databaseProviderName !== undefined) {
                localVarQueryParameter['Database.ProviderName'] = databaseProviderName;
            }

            if (changeTrackerAutoDetectChangesEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.AutoDetectChangesEnabled'] = changeTrackerAutoDetectChangesEnabled;
            }

            if (changeTrackerLazyLoadingEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.LazyLoadingEnabled'] = changeTrackerLazyLoadingEnabled;
            }

            if (changeTrackerQueryTrackingBehavior !== undefined) {
                localVarQueryParameter['ChangeTracker.QueryTrackingBehavior'] = changeTrackerQueryTrackingBehavior;
            }

            if (changeTrackerDeleteOrphansTiming !== undefined) {
                localVarQueryParameter['ChangeTracker.DeleteOrphansTiming'] = changeTrackerDeleteOrphansTiming;
            }

            if (changeTrackerCascadeDeleteTiming !== undefined) {
                localVarQueryParameter['ChangeTracker.CascadeDeleteTiming'] = changeTrackerCascadeDeleteTiming;
            }

            if (changeTrackerContextDatabaseCurrentTransactionTransactionId !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.Database.CurrentTransaction.TransactionId'] = changeTrackerContextDatabaseCurrentTransactionTransactionId;
            }

            if (changeTrackerContextDatabaseAutoTransactionsEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.Database.AutoTransactionsEnabled'] = changeTrackerContextDatabaseAutoTransactionsEnabled;
            }

            if (changeTrackerContextDatabaseProviderName !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.Database.ProviderName'] = changeTrackerContextDatabaseProviderName;
            }

            if (changeTrackerContextChangeTrackerAutoDetectChangesEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.AutoDetectChangesEnabled'] = changeTrackerContextChangeTrackerAutoDetectChangesEnabled;
            }

            if (changeTrackerContextChangeTrackerLazyLoadingEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.LazyLoadingEnabled'] = changeTrackerContextChangeTrackerLazyLoadingEnabled;
            }

            if (changeTrackerContextChangeTrackerQueryTrackingBehavior !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.QueryTrackingBehavior'] = changeTrackerContextChangeTrackerQueryTrackingBehavior;
            }

            if (changeTrackerContextChangeTrackerDeleteOrphansTiming !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.DeleteOrphansTiming'] = changeTrackerContextChangeTrackerDeleteOrphansTiming;
            }

            if (changeTrackerContextChangeTrackerCascadeDeleteTiming !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.CascadeDeleteTiming'] = changeTrackerContextChangeTrackerCascadeDeleteTiming;
            }

            if (changeTrackerContextChangeTrackerContext !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.Context'] = changeTrackerContextChangeTrackerContext;
            }

            if (changeTrackerContextModel !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.Model'] = changeTrackerContextModel;
            }

            if (changeTrackerContextContextIdInstanceId !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ContextId.InstanceId'] = changeTrackerContextContextIdInstanceId;
            }

            if (changeTrackerContextContextIdLease !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ContextId.Lease'] = changeTrackerContextContextIdLease;
            }

            if (model !== undefined) {
                localVarQueryParameter['Model'] = model;
            }

            if (contextIdInstanceId !== undefined) {
                localVarQueryParameter['ContextId.InstanceId'] = contextIdInstanceId;
            }

            if (contextIdLease !== undefined) {
                localVarQueryParameter['ContextId.Lease'] = contextIdLease;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApplicationqrcommandPost: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/applicationqrcommand`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [code] 
         * @param {boolean} [isInApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userConfirmemailGet: async (userId?: string, code?: string, isInApp?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/confirmemail`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (code !== undefined) {
                localVarQueryParameter['Code'] = code;
            }

            if (isInApp !== undefined) {
                localVarQueryParameter['IsInApp'] = isInApp;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EnableDisable2Fa} [enableDisable2Fa] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDisable2faPost: async (enableDisable2Fa?: EnableDisable2Fa, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/disable2fa`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof enableDisable2Fa !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(enableDisable2Fa !== undefined ? enableDisable2Fa : {}) : (enableDisable2Fa || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EnableDisable2Fa} [enableDisable2Fa] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnable2faPost: async (enableDisable2Fa?: EnableDisable2Fa, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/enable2fa`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof enableDisable2Fa !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(enableDisable2Fa !== undefined ? enableDisable2Fa : {}) : (enableDisable2Fa || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExternaltokenPost: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/externaltoken`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<CryptoCurrency>} [cryptoCurrencies] 
         * @param {Array<Order>} [orders] 
         * @param {Array<DepositAddress>} [depositAddresses] 
         * @param {Array<Balance>} [userBalances] 
         * @param {Array<Market>} [markets] 
         * @param {Array<TradingPair>} [tradingPairs] 
         * @param {Array<Transaction>} [transactions] 
         * @param {Array<WithdrawRequest>} [withdrawRequests] 
         * @param {Array<ManualWithdrawRequest>} [manualWithdrawRequests] 
         * @param {Array<Trade>} [trades] 
         * @param {Array<Quote>} [quotes] 
         * @param {Array<SmsVerificationMessage>} [smsVerificationMessages] 
         * @param {Array<TradingAmount>} [tradingAmounts] 
         * @param {Array<RippleDestinationTag>} [rippleDestinationTags] 
         * @param {Array<BitcoinBasedCurrency>} [bitcoinBasedCurrencies] 
         * @param {Array<ERC20Token>} [eRC20Tokens] 
         * @param {Array<BalanceAction>} [balanceActions] 
         * @param {Array<KeyValue>} [keysValues] 
         * @param {Array<IApplicationTokenAccess>} [applicationTokenAccesses] 
         * @param {Array<IApplicationQrCommand>} [applicationQrCommands] 
         * @param {Array<PushToken>} [pushTokens] 
         * @param {Array<StringIdentityUserRole>} [userRoles] 
         * @param {Array<IdentityRole>} [roles] 
         * @param {Array<StringIdentityRoleClaim>} [roleClaims] 
         * @param {Array<ApplicationUser>} [users] 
         * @param {Array<StringIdentityUserClaim>} [userClaims] 
         * @param {Array<StringIdentityUserLogin>} [userLogins] 
         * @param {Array<StringIdentityUserToken>} [userTokens] 
         * @param {string} [databaseCurrentTransactionTransactionId] 
         * @param {boolean} [databaseAutoTransactionsEnabled] 
         * @param {string} [databaseProviderName] 
         * @param {boolean} [changeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerCascadeDeleteTiming] 
         * @param {string} [changeTrackerContextDatabaseCurrentTransactionTransactionId] 
         * @param {boolean} [changeTrackerContextDatabaseAutoTransactionsEnabled] 
         * @param {string} [changeTrackerContextDatabaseProviderName] 
         * @param {boolean} [changeTrackerContextChangeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerContextChangeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerContextChangeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerCascadeDeleteTiming] 
         * @param {DbContext} [changeTrackerContextChangeTrackerContext] 
         * @param {object} [changeTrackerContextModel] 
         * @param {string} [changeTrackerContextContextIdInstanceId] 
         * @param {number} [changeTrackerContextContextIdLease] 
         * @param {object} [model] 
         * @param {string} [contextIdInstanceId] 
         * @param {number} [contextIdLease] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetapptokenPost: async (cryptoCurrencies?: Array<CryptoCurrency>, orders?: Array<Order>, depositAddresses?: Array<DepositAddress>, userBalances?: Array<Balance>, markets?: Array<Market>, tradingPairs?: Array<TradingPair>, transactions?: Array<Transaction>, withdrawRequests?: Array<WithdrawRequest>, manualWithdrawRequests?: Array<ManualWithdrawRequest>, trades?: Array<Trade>, quotes?: Array<Quote>, smsVerificationMessages?: Array<SmsVerificationMessage>, tradingAmounts?: Array<TradingAmount>, rippleDestinationTags?: Array<RippleDestinationTag>, bitcoinBasedCurrencies?: Array<BitcoinBasedCurrency>, eRC20Tokens?: Array<ERC20Token>, balanceActions?: Array<BalanceAction>, keysValues?: Array<KeyValue>, applicationTokenAccesses?: Array<IApplicationTokenAccess>, applicationQrCommands?: Array<IApplicationQrCommand>, pushTokens?: Array<PushToken>, userRoles?: Array<StringIdentityUserRole>, roles?: Array<IdentityRole>, roleClaims?: Array<StringIdentityRoleClaim>, users?: Array<ApplicationUser>, userClaims?: Array<StringIdentityUserClaim>, userLogins?: Array<StringIdentityUserLogin>, userTokens?: Array<StringIdentityUserToken>, databaseCurrentTransactionTransactionId?: string, databaseAutoTransactionsEnabled?: boolean, databaseProviderName?: string, changeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerLazyLoadingEnabled?: boolean, changeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId?: string, changeTrackerContextDatabaseAutoTransactionsEnabled?: boolean, changeTrackerContextDatabaseProviderName?: string, changeTrackerContextChangeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerContextChangeTrackerLazyLoadingEnabled?: boolean, changeTrackerContextChangeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextChangeTrackerContext?: DbContext, changeTrackerContextModel?: object, changeTrackerContextContextIdInstanceId?: string, changeTrackerContextContextIdLease?: number, model?: object, contextIdInstanceId?: string, contextIdLease?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/getapptoken`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (cryptoCurrencies) {
                localVarQueryParameter['CryptoCurrencies'] = cryptoCurrencies;
            }

            if (orders) {
                localVarQueryParameter['Orders'] = orders;
            }

            if (depositAddresses) {
                localVarQueryParameter['DepositAddresses'] = depositAddresses;
            }

            if (userBalances) {
                localVarQueryParameter['UserBalances'] = userBalances;
            }

            if (markets) {
                localVarQueryParameter['Markets'] = markets;
            }

            if (tradingPairs) {
                localVarQueryParameter['TradingPairs'] = tradingPairs;
            }

            if (transactions) {
                localVarQueryParameter['Transactions'] = transactions;
            }

            if (withdrawRequests) {
                localVarQueryParameter['WithdrawRequests'] = withdrawRequests;
            }

            if (manualWithdrawRequests) {
                localVarQueryParameter['ManualWithdrawRequests'] = manualWithdrawRequests;
            }

            if (trades) {
                localVarQueryParameter['Trades'] = trades;
            }

            if (quotes) {
                localVarQueryParameter['Quotes'] = quotes;
            }

            if (smsVerificationMessages) {
                localVarQueryParameter['SmsVerificationMessages'] = smsVerificationMessages;
            }

            if (tradingAmounts) {
                localVarQueryParameter['TradingAmounts'] = tradingAmounts;
            }

            if (rippleDestinationTags) {
                localVarQueryParameter['RippleDestinationTags'] = rippleDestinationTags;
            }

            if (bitcoinBasedCurrencies) {
                localVarQueryParameter['BitcoinBasedCurrencies'] = bitcoinBasedCurrencies;
            }

            if (eRC20Tokens) {
                localVarQueryParameter['ERC20Tokens'] = eRC20Tokens;
            }

            if (balanceActions) {
                localVarQueryParameter['BalanceActions'] = balanceActions;
            }

            if (keysValues) {
                localVarQueryParameter['KeysValues'] = keysValues;
            }

            if (applicationTokenAccesses) {
                localVarQueryParameter['ApplicationTokenAccesses'] = applicationTokenAccesses;
            }

            if (applicationQrCommands) {
                localVarQueryParameter['ApplicationQrCommands'] = applicationQrCommands;
            }

            if (pushTokens) {
                localVarQueryParameter['PushTokens'] = pushTokens;
            }

            if (userRoles) {
                localVarQueryParameter['UserRoles'] = userRoles;
            }

            if (roles) {
                localVarQueryParameter['Roles'] = roles;
            }

            if (roleClaims) {
                localVarQueryParameter['RoleClaims'] = roleClaims;
            }

            if (users) {
                localVarQueryParameter['Users'] = users;
            }

            if (userClaims) {
                localVarQueryParameter['UserClaims'] = userClaims;
            }

            if (userLogins) {
                localVarQueryParameter['UserLogins'] = userLogins;
            }

            if (userTokens) {
                localVarQueryParameter['UserTokens'] = userTokens;
            }

            if (databaseCurrentTransactionTransactionId !== undefined) {
                localVarQueryParameter['Database.CurrentTransaction.TransactionId'] = databaseCurrentTransactionTransactionId;
            }

            if (databaseAutoTransactionsEnabled !== undefined) {
                localVarQueryParameter['Database.AutoTransactionsEnabled'] = databaseAutoTransactionsEnabled;
            }

            if (databaseProviderName !== undefined) {
                localVarQueryParameter['Database.ProviderName'] = databaseProviderName;
            }

            if (changeTrackerAutoDetectChangesEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.AutoDetectChangesEnabled'] = changeTrackerAutoDetectChangesEnabled;
            }

            if (changeTrackerLazyLoadingEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.LazyLoadingEnabled'] = changeTrackerLazyLoadingEnabled;
            }

            if (changeTrackerQueryTrackingBehavior !== undefined) {
                localVarQueryParameter['ChangeTracker.QueryTrackingBehavior'] = changeTrackerQueryTrackingBehavior;
            }

            if (changeTrackerDeleteOrphansTiming !== undefined) {
                localVarQueryParameter['ChangeTracker.DeleteOrphansTiming'] = changeTrackerDeleteOrphansTiming;
            }

            if (changeTrackerCascadeDeleteTiming !== undefined) {
                localVarQueryParameter['ChangeTracker.CascadeDeleteTiming'] = changeTrackerCascadeDeleteTiming;
            }

            if (changeTrackerContextDatabaseCurrentTransactionTransactionId !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.Database.CurrentTransaction.TransactionId'] = changeTrackerContextDatabaseCurrentTransactionTransactionId;
            }

            if (changeTrackerContextDatabaseAutoTransactionsEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.Database.AutoTransactionsEnabled'] = changeTrackerContextDatabaseAutoTransactionsEnabled;
            }

            if (changeTrackerContextDatabaseProviderName !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.Database.ProviderName'] = changeTrackerContextDatabaseProviderName;
            }

            if (changeTrackerContextChangeTrackerAutoDetectChangesEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.AutoDetectChangesEnabled'] = changeTrackerContextChangeTrackerAutoDetectChangesEnabled;
            }

            if (changeTrackerContextChangeTrackerLazyLoadingEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.LazyLoadingEnabled'] = changeTrackerContextChangeTrackerLazyLoadingEnabled;
            }

            if (changeTrackerContextChangeTrackerQueryTrackingBehavior !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.QueryTrackingBehavior'] = changeTrackerContextChangeTrackerQueryTrackingBehavior;
            }

            if (changeTrackerContextChangeTrackerDeleteOrphansTiming !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.DeleteOrphansTiming'] = changeTrackerContextChangeTrackerDeleteOrphansTiming;
            }

            if (changeTrackerContextChangeTrackerCascadeDeleteTiming !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.CascadeDeleteTiming'] = changeTrackerContextChangeTrackerCascadeDeleteTiming;
            }

            if (changeTrackerContextChangeTrackerContext !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.Context'] = changeTrackerContextChangeTrackerContext;
            }

            if (changeTrackerContextModel !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.Model'] = changeTrackerContextModel;
            }

            if (changeTrackerContextContextIdInstanceId !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ContextId.InstanceId'] = changeTrackerContextContextIdInstanceId;
            }

            if (changeTrackerContextContextIdLease !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ContextId.Lease'] = changeTrackerContextContextIdLease;
            }

            if (model !== undefined) {
                localVarQueryParameter['Model'] = model;
            }

            if (contextIdInstanceId !== undefined) {
                localVarQueryParameter['ContextId.InstanceId'] = contextIdInstanceId;
            }

            if (contextIdLease !== undefined) {
                localVarQueryParameter['ContextId.Lease'] = contextIdLease;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostGetReferrerEmailRequest} [postGetReferrerEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetreferreremailPost: async (postGetReferrerEmailRequest?: PostGetReferrerEmailRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/getreferreremail`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof postGetReferrerEmailRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postGetReferrerEmailRequest !== undefined ? postGetReferrerEmailRequest : {}) : (postGetReferrerEmailRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userResetpasswordPost: async (resetPassword?: ResetPassword, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/resetpassword`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resetPassword !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resetPassword !== undefined ? resetPassword : {}) : (resetPassword || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ForgotPassword} [forgotPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRestorepasswordPost: async (forgotPassword?: ForgotPassword, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/restorepassword`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof forgotPassword !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(forgotPassword !== undefined ? forgotPassword : {}) : (forgotPassword || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostSendSms} [postSendSms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSendsmscodePost: async (postSendSms?: PostSendSms, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/sendsmscode`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof postSendSms !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postSendSms !== undefined ? postSendSms : {}) : (postSendSms || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<CryptoCurrency>} [cryptoCurrencies] 
         * @param {Array<Order>} [orders] 
         * @param {Array<DepositAddress>} [depositAddresses] 
         * @param {Array<Balance>} [userBalances] 
         * @param {Array<Market>} [markets] 
         * @param {Array<TradingPair>} [tradingPairs] 
         * @param {Array<Transaction>} [transactions] 
         * @param {Array<WithdrawRequest>} [withdrawRequests] 
         * @param {Array<ManualWithdrawRequest>} [manualWithdrawRequests] 
         * @param {Array<Trade>} [trades] 
         * @param {Array<Quote>} [quotes] 
         * @param {Array<SmsVerificationMessage>} [smsVerificationMessages] 
         * @param {Array<TradingAmount>} [tradingAmounts] 
         * @param {Array<RippleDestinationTag>} [rippleDestinationTags] 
         * @param {Array<BitcoinBasedCurrency>} [bitcoinBasedCurrencies] 
         * @param {Array<ERC20Token>} [eRC20Tokens] 
         * @param {Array<BalanceAction>} [balanceActions] 
         * @param {Array<KeyValue>} [keysValues] 
         * @param {Array<IApplicationTokenAccess>} [applicationTokenAccesses] 
         * @param {Array<IApplicationQrCommand>} [applicationQrCommands] 
         * @param {Array<PushToken>} [pushTokens] 
         * @param {Array<StringIdentityUserRole>} [userRoles] 
         * @param {Array<IdentityRole>} [roles] 
         * @param {Array<StringIdentityRoleClaim>} [roleClaims] 
         * @param {Array<ApplicationUser>} [users] 
         * @param {Array<StringIdentityUserClaim>} [userClaims] 
         * @param {Array<StringIdentityUserLogin>} [userLogins] 
         * @param {Array<StringIdentityUserToken>} [userTokens] 
         * @param {string} [databaseCurrentTransactionTransactionId] 
         * @param {boolean} [databaseAutoTransactionsEnabled] 
         * @param {string} [databaseProviderName] 
         * @param {boolean} [changeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerCascadeDeleteTiming] 
         * @param {string} [changeTrackerContextDatabaseCurrentTransactionTransactionId] 
         * @param {boolean} [changeTrackerContextDatabaseAutoTransactionsEnabled] 
         * @param {string} [changeTrackerContextDatabaseProviderName] 
         * @param {boolean} [changeTrackerContextChangeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerContextChangeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerContextChangeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerCascadeDeleteTiming] 
         * @param {DbContext} [changeTrackerContextChangeTrackerContext] 
         * @param {object} [changeTrackerContextModel] 
         * @param {string} [changeTrackerContextContextIdInstanceId] 
         * @param {number} [changeTrackerContextContextIdLease] 
         * @param {object} [model] 
         * @param {string} [contextIdInstanceId] 
         * @param {number} [contextIdLease] 
         * @param {PostSetAffiliateRequest} [postSetAffiliateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSetAffiliatePost: async (cryptoCurrencies?: Array<CryptoCurrency>, orders?: Array<Order>, depositAddresses?: Array<DepositAddress>, userBalances?: Array<Balance>, markets?: Array<Market>, tradingPairs?: Array<TradingPair>, transactions?: Array<Transaction>, withdrawRequests?: Array<WithdrawRequest>, manualWithdrawRequests?: Array<ManualWithdrawRequest>, trades?: Array<Trade>, quotes?: Array<Quote>, smsVerificationMessages?: Array<SmsVerificationMessage>, tradingAmounts?: Array<TradingAmount>, rippleDestinationTags?: Array<RippleDestinationTag>, bitcoinBasedCurrencies?: Array<BitcoinBasedCurrency>, eRC20Tokens?: Array<ERC20Token>, balanceActions?: Array<BalanceAction>, keysValues?: Array<KeyValue>, applicationTokenAccesses?: Array<IApplicationTokenAccess>, applicationQrCommands?: Array<IApplicationQrCommand>, pushTokens?: Array<PushToken>, userRoles?: Array<StringIdentityUserRole>, roles?: Array<IdentityRole>, roleClaims?: Array<StringIdentityRoleClaim>, users?: Array<ApplicationUser>, userClaims?: Array<StringIdentityUserClaim>, userLogins?: Array<StringIdentityUserLogin>, userTokens?: Array<StringIdentityUserToken>, databaseCurrentTransactionTransactionId?: string, databaseAutoTransactionsEnabled?: boolean, databaseProviderName?: string, changeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerLazyLoadingEnabled?: boolean, changeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId?: string, changeTrackerContextDatabaseAutoTransactionsEnabled?: boolean, changeTrackerContextDatabaseProviderName?: string, changeTrackerContextChangeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerContextChangeTrackerLazyLoadingEnabled?: boolean, changeTrackerContextChangeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextChangeTrackerContext?: DbContext, changeTrackerContextModel?: object, changeTrackerContextContextIdInstanceId?: string, changeTrackerContextContextIdLease?: number, model?: object, contextIdInstanceId?: string, contextIdLease?: number, postSetAffiliateRequest?: PostSetAffiliateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/setAffiliate`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (cryptoCurrencies) {
                localVarQueryParameter['CryptoCurrencies'] = cryptoCurrencies;
            }

            if (orders) {
                localVarQueryParameter['Orders'] = orders;
            }

            if (depositAddresses) {
                localVarQueryParameter['DepositAddresses'] = depositAddresses;
            }

            if (userBalances) {
                localVarQueryParameter['UserBalances'] = userBalances;
            }

            if (markets) {
                localVarQueryParameter['Markets'] = markets;
            }

            if (tradingPairs) {
                localVarQueryParameter['TradingPairs'] = tradingPairs;
            }

            if (transactions) {
                localVarQueryParameter['Transactions'] = transactions;
            }

            if (withdrawRequests) {
                localVarQueryParameter['WithdrawRequests'] = withdrawRequests;
            }

            if (manualWithdrawRequests) {
                localVarQueryParameter['ManualWithdrawRequests'] = manualWithdrawRequests;
            }

            if (trades) {
                localVarQueryParameter['Trades'] = trades;
            }

            if (quotes) {
                localVarQueryParameter['Quotes'] = quotes;
            }

            if (smsVerificationMessages) {
                localVarQueryParameter['SmsVerificationMessages'] = smsVerificationMessages;
            }

            if (tradingAmounts) {
                localVarQueryParameter['TradingAmounts'] = tradingAmounts;
            }

            if (rippleDestinationTags) {
                localVarQueryParameter['RippleDestinationTags'] = rippleDestinationTags;
            }

            if (bitcoinBasedCurrencies) {
                localVarQueryParameter['BitcoinBasedCurrencies'] = bitcoinBasedCurrencies;
            }

            if (eRC20Tokens) {
                localVarQueryParameter['ERC20Tokens'] = eRC20Tokens;
            }

            if (balanceActions) {
                localVarQueryParameter['BalanceActions'] = balanceActions;
            }

            if (keysValues) {
                localVarQueryParameter['KeysValues'] = keysValues;
            }

            if (applicationTokenAccesses) {
                localVarQueryParameter['ApplicationTokenAccesses'] = applicationTokenAccesses;
            }

            if (applicationQrCommands) {
                localVarQueryParameter['ApplicationQrCommands'] = applicationQrCommands;
            }

            if (pushTokens) {
                localVarQueryParameter['PushTokens'] = pushTokens;
            }

            if (userRoles) {
                localVarQueryParameter['UserRoles'] = userRoles;
            }

            if (roles) {
                localVarQueryParameter['Roles'] = roles;
            }

            if (roleClaims) {
                localVarQueryParameter['RoleClaims'] = roleClaims;
            }

            if (users) {
                localVarQueryParameter['Users'] = users;
            }

            if (userClaims) {
                localVarQueryParameter['UserClaims'] = userClaims;
            }

            if (userLogins) {
                localVarQueryParameter['UserLogins'] = userLogins;
            }

            if (userTokens) {
                localVarQueryParameter['UserTokens'] = userTokens;
            }

            if (databaseCurrentTransactionTransactionId !== undefined) {
                localVarQueryParameter['Database.CurrentTransaction.TransactionId'] = databaseCurrentTransactionTransactionId;
            }

            if (databaseAutoTransactionsEnabled !== undefined) {
                localVarQueryParameter['Database.AutoTransactionsEnabled'] = databaseAutoTransactionsEnabled;
            }

            if (databaseProviderName !== undefined) {
                localVarQueryParameter['Database.ProviderName'] = databaseProviderName;
            }

            if (changeTrackerAutoDetectChangesEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.AutoDetectChangesEnabled'] = changeTrackerAutoDetectChangesEnabled;
            }

            if (changeTrackerLazyLoadingEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.LazyLoadingEnabled'] = changeTrackerLazyLoadingEnabled;
            }

            if (changeTrackerQueryTrackingBehavior !== undefined) {
                localVarQueryParameter['ChangeTracker.QueryTrackingBehavior'] = changeTrackerQueryTrackingBehavior;
            }

            if (changeTrackerDeleteOrphansTiming !== undefined) {
                localVarQueryParameter['ChangeTracker.DeleteOrphansTiming'] = changeTrackerDeleteOrphansTiming;
            }

            if (changeTrackerCascadeDeleteTiming !== undefined) {
                localVarQueryParameter['ChangeTracker.CascadeDeleteTiming'] = changeTrackerCascadeDeleteTiming;
            }

            if (changeTrackerContextDatabaseCurrentTransactionTransactionId !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.Database.CurrentTransaction.TransactionId'] = changeTrackerContextDatabaseCurrentTransactionTransactionId;
            }

            if (changeTrackerContextDatabaseAutoTransactionsEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.Database.AutoTransactionsEnabled'] = changeTrackerContextDatabaseAutoTransactionsEnabled;
            }

            if (changeTrackerContextDatabaseProviderName !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.Database.ProviderName'] = changeTrackerContextDatabaseProviderName;
            }

            if (changeTrackerContextChangeTrackerAutoDetectChangesEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.AutoDetectChangesEnabled'] = changeTrackerContextChangeTrackerAutoDetectChangesEnabled;
            }

            if (changeTrackerContextChangeTrackerLazyLoadingEnabled !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.LazyLoadingEnabled'] = changeTrackerContextChangeTrackerLazyLoadingEnabled;
            }

            if (changeTrackerContextChangeTrackerQueryTrackingBehavior !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.QueryTrackingBehavior'] = changeTrackerContextChangeTrackerQueryTrackingBehavior;
            }

            if (changeTrackerContextChangeTrackerDeleteOrphansTiming !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.DeleteOrphansTiming'] = changeTrackerContextChangeTrackerDeleteOrphansTiming;
            }

            if (changeTrackerContextChangeTrackerCascadeDeleteTiming !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.CascadeDeleteTiming'] = changeTrackerContextChangeTrackerCascadeDeleteTiming;
            }

            if (changeTrackerContextChangeTrackerContext !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ChangeTracker.Context'] = changeTrackerContextChangeTrackerContext;
            }

            if (changeTrackerContextModel !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.Model'] = changeTrackerContextModel;
            }

            if (changeTrackerContextContextIdInstanceId !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ContextId.InstanceId'] = changeTrackerContextContextIdInstanceId;
            }

            if (changeTrackerContextContextIdLease !== undefined) {
                localVarQueryParameter['ChangeTracker.Context.ContextId.Lease'] = changeTrackerContextContextIdLease;
            }

            if (model !== undefined) {
                localVarQueryParameter['Model'] = model;
            }

            if (contextIdInstanceId !== undefined) {
                localVarQueryParameter['ContextId.InstanceId'] = contextIdInstanceId;
            }

            if (contextIdLease !== undefined) {
                localVarQueryParameter['ContextId.Lease'] = contextIdLease;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof postSetAffiliateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postSetAffiliateRequest !== undefined ? postSetAffiliateRequest : {}) : (postSetAffiliateRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignIn} [signIn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSigninPost: async (signIn?: SignIn, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/signin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof signIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(signIn !== undefined ? signIn : {}) : (signIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUp} [signUp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSignupPost: async (signUp?: SignUp, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/signup`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof signUp !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(signUp !== undefined ? signUp : {}) : (signUp || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userValidatePinPost: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/validatePin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userVerificationsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/verifications`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostVefirySms} [postVefirySms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userVerifysmscodePost: async (postVefirySms?: PostVefirySms, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/verifysmscode`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof postVefirySms !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postVefirySms !== undefined ? postVefirySms : {}) : (postVefirySms || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userWithdrawalsGet: async (currency?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/User/withdrawals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserBalanceactionsGet(page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserBalanceactionsGet(page, size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserBalancesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserBalancesGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserBalanceslistGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserBalanceslistGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserDepositsGet(currency?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserDepositsGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserGetapptokenGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserGetapptokenGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserOrdersGet(pair?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserOrdersGet(pair, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserTradehistoryGet(page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserTradehistoryGet(page, size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserValidateOauthGet(id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserValidateOauthGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserValidateapptokenPost(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserValidateapptokenPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserWithdrawalsGet(currency?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserWithdrawalsGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async user2faPost(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).user2faPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Array<CryptoCurrency>} [cryptoCurrencies] 
         * @param {Array<Order>} [orders] 
         * @param {Array<DepositAddress>} [depositAddresses] 
         * @param {Array<Balance>} [userBalances] 
         * @param {Array<Market>} [markets] 
         * @param {Array<TradingPair>} [tradingPairs] 
         * @param {Array<Transaction>} [transactions] 
         * @param {Array<WithdrawRequest>} [withdrawRequests] 
         * @param {Array<ManualWithdrawRequest>} [manualWithdrawRequests] 
         * @param {Array<Trade>} [trades] 
         * @param {Array<Quote>} [quotes] 
         * @param {Array<SmsVerificationMessage>} [smsVerificationMessages] 
         * @param {Array<TradingAmount>} [tradingAmounts] 
         * @param {Array<RippleDestinationTag>} [rippleDestinationTags] 
         * @param {Array<BitcoinBasedCurrency>} [bitcoinBasedCurrencies] 
         * @param {Array<ERC20Token>} [eRC20Tokens] 
         * @param {Array<BalanceAction>} [balanceActions] 
         * @param {Array<KeyValue>} [keysValues] 
         * @param {Array<IApplicationTokenAccess>} [applicationTokenAccesses] 
         * @param {Array<IApplicationQrCommand>} [applicationQrCommands] 
         * @param {Array<PushToken>} [pushTokens] 
         * @param {Array<StringIdentityUserRole>} [userRoles] 
         * @param {Array<IdentityRole>} [roles] 
         * @param {Array<StringIdentityRoleClaim>} [roleClaims] 
         * @param {Array<ApplicationUser>} [users] 
         * @param {Array<StringIdentityUserClaim>} [userClaims] 
         * @param {Array<StringIdentityUserLogin>} [userLogins] 
         * @param {Array<StringIdentityUserToken>} [userTokens] 
         * @param {string} [databaseCurrentTransactionTransactionId] 
         * @param {boolean} [databaseAutoTransactionsEnabled] 
         * @param {string} [databaseProviderName] 
         * @param {boolean} [changeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerCascadeDeleteTiming] 
         * @param {string} [changeTrackerContextDatabaseCurrentTransactionTransactionId] 
         * @param {boolean} [changeTrackerContextDatabaseAutoTransactionsEnabled] 
         * @param {string} [changeTrackerContextDatabaseProviderName] 
         * @param {boolean} [changeTrackerContextChangeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerContextChangeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerContextChangeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerCascadeDeleteTiming] 
         * @param {DbContext} [changeTrackerContextChangeTrackerContext] 
         * @param {object} [changeTrackerContextModel] 
         * @param {string} [changeTrackerContextContextIdInstanceId] 
         * @param {number} [changeTrackerContextContextIdLease] 
         * @param {object} [model] 
         * @param {string} [contextIdInstanceId] 
         * @param {number} [contextIdLease] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAffiliatedataPost(cryptoCurrencies?: Array<CryptoCurrency>, orders?: Array<Order>, depositAddresses?: Array<DepositAddress>, userBalances?: Array<Balance>, markets?: Array<Market>, tradingPairs?: Array<TradingPair>, transactions?: Array<Transaction>, withdrawRequests?: Array<WithdrawRequest>, manualWithdrawRequests?: Array<ManualWithdrawRequest>, trades?: Array<Trade>, quotes?: Array<Quote>, smsVerificationMessages?: Array<SmsVerificationMessage>, tradingAmounts?: Array<TradingAmount>, rippleDestinationTags?: Array<RippleDestinationTag>, bitcoinBasedCurrencies?: Array<BitcoinBasedCurrency>, eRC20Tokens?: Array<ERC20Token>, balanceActions?: Array<BalanceAction>, keysValues?: Array<KeyValue>, applicationTokenAccesses?: Array<IApplicationTokenAccess>, applicationQrCommands?: Array<IApplicationQrCommand>, pushTokens?: Array<PushToken>, userRoles?: Array<StringIdentityUserRole>, roles?: Array<IdentityRole>, roleClaims?: Array<StringIdentityRoleClaim>, users?: Array<ApplicationUser>, userClaims?: Array<StringIdentityUserClaim>, userLogins?: Array<StringIdentityUserLogin>, userTokens?: Array<StringIdentityUserToken>, databaseCurrentTransactionTransactionId?: string, databaseAutoTransactionsEnabled?: boolean, databaseProviderName?: string, changeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerLazyLoadingEnabled?: boolean, changeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId?: string, changeTrackerContextDatabaseAutoTransactionsEnabled?: boolean, changeTrackerContextDatabaseProviderName?: string, changeTrackerContextChangeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerContextChangeTrackerLazyLoadingEnabled?: boolean, changeTrackerContextChangeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextChangeTrackerContext?: DbContext, changeTrackerContextModel?: object, changeTrackerContextContextIdInstanceId?: string, changeTrackerContextContextIdLease?: number, model?: object, contextIdInstanceId?: string, contextIdLease?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userAffiliatedataPost(cryptoCurrencies, orders, depositAddresses, userBalances, markets, tradingPairs, transactions, withdrawRequests, manualWithdrawRequests, trades, quotes, smsVerificationMessages, tradingAmounts, rippleDestinationTags, bitcoinBasedCurrencies, eRC20Tokens, balanceActions, keysValues, applicationTokenAccesses, applicationQrCommands, pushTokens, userRoles, roles, roleClaims, users, userClaims, userLogins, userTokens, databaseCurrentTransactionTransactionId, databaseAutoTransactionsEnabled, databaseProviderName, changeTrackerAutoDetectChangesEnabled, changeTrackerLazyLoadingEnabled, changeTrackerQueryTrackingBehavior, changeTrackerDeleteOrphansTiming, changeTrackerCascadeDeleteTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId, changeTrackerContextDatabaseAutoTransactionsEnabled, changeTrackerContextDatabaseProviderName, changeTrackerContextChangeTrackerAutoDetectChangesEnabled, changeTrackerContextChangeTrackerLazyLoadingEnabled, changeTrackerContextChangeTrackerQueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming, changeTrackerContextChangeTrackerContext, changeTrackerContextModel, changeTrackerContextContextIdInstanceId, changeTrackerContextContextIdLease, model, contextIdInstanceId, contextIdLease, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userApplicationqrcommandPost(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userApplicationqrcommandPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [code] 
         * @param {boolean} [isInApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userConfirmemailGet(userId?: string, code?: string, isInApp?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userConfirmemailGet(userId, code, isInApp, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {EnableDisable2Fa} [enableDisable2Fa] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDisable2faPost(enableDisable2Fa?: EnableDisable2Fa, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userDisable2faPost(enableDisable2Fa, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {EnableDisable2Fa} [enableDisable2Fa] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userEnable2faPost(enableDisable2Fa?: EnableDisable2Fa, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userEnable2faPost(enableDisable2Fa, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userExternaltokenPost(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userExternaltokenPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Array<CryptoCurrency>} [cryptoCurrencies] 
         * @param {Array<Order>} [orders] 
         * @param {Array<DepositAddress>} [depositAddresses] 
         * @param {Array<Balance>} [userBalances] 
         * @param {Array<Market>} [markets] 
         * @param {Array<TradingPair>} [tradingPairs] 
         * @param {Array<Transaction>} [transactions] 
         * @param {Array<WithdrawRequest>} [withdrawRequests] 
         * @param {Array<ManualWithdrawRequest>} [manualWithdrawRequests] 
         * @param {Array<Trade>} [trades] 
         * @param {Array<Quote>} [quotes] 
         * @param {Array<SmsVerificationMessage>} [smsVerificationMessages] 
         * @param {Array<TradingAmount>} [tradingAmounts] 
         * @param {Array<RippleDestinationTag>} [rippleDestinationTags] 
         * @param {Array<BitcoinBasedCurrency>} [bitcoinBasedCurrencies] 
         * @param {Array<ERC20Token>} [eRC20Tokens] 
         * @param {Array<BalanceAction>} [balanceActions] 
         * @param {Array<KeyValue>} [keysValues] 
         * @param {Array<IApplicationTokenAccess>} [applicationTokenAccesses] 
         * @param {Array<IApplicationQrCommand>} [applicationQrCommands] 
         * @param {Array<PushToken>} [pushTokens] 
         * @param {Array<StringIdentityUserRole>} [userRoles] 
         * @param {Array<IdentityRole>} [roles] 
         * @param {Array<StringIdentityRoleClaim>} [roleClaims] 
         * @param {Array<ApplicationUser>} [users] 
         * @param {Array<StringIdentityUserClaim>} [userClaims] 
         * @param {Array<StringIdentityUserLogin>} [userLogins] 
         * @param {Array<StringIdentityUserToken>} [userTokens] 
         * @param {string} [databaseCurrentTransactionTransactionId] 
         * @param {boolean} [databaseAutoTransactionsEnabled] 
         * @param {string} [databaseProviderName] 
         * @param {boolean} [changeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerCascadeDeleteTiming] 
         * @param {string} [changeTrackerContextDatabaseCurrentTransactionTransactionId] 
         * @param {boolean} [changeTrackerContextDatabaseAutoTransactionsEnabled] 
         * @param {string} [changeTrackerContextDatabaseProviderName] 
         * @param {boolean} [changeTrackerContextChangeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerContextChangeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerContextChangeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerCascadeDeleteTiming] 
         * @param {DbContext} [changeTrackerContextChangeTrackerContext] 
         * @param {object} [changeTrackerContextModel] 
         * @param {string} [changeTrackerContextContextIdInstanceId] 
         * @param {number} [changeTrackerContextContextIdLease] 
         * @param {object} [model] 
         * @param {string} [contextIdInstanceId] 
         * @param {number} [contextIdLease] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetapptokenPost(cryptoCurrencies?: Array<CryptoCurrency>, orders?: Array<Order>, depositAddresses?: Array<DepositAddress>, userBalances?: Array<Balance>, markets?: Array<Market>, tradingPairs?: Array<TradingPair>, transactions?: Array<Transaction>, withdrawRequests?: Array<WithdrawRequest>, manualWithdrawRequests?: Array<ManualWithdrawRequest>, trades?: Array<Trade>, quotes?: Array<Quote>, smsVerificationMessages?: Array<SmsVerificationMessage>, tradingAmounts?: Array<TradingAmount>, rippleDestinationTags?: Array<RippleDestinationTag>, bitcoinBasedCurrencies?: Array<BitcoinBasedCurrency>, eRC20Tokens?: Array<ERC20Token>, balanceActions?: Array<BalanceAction>, keysValues?: Array<KeyValue>, applicationTokenAccesses?: Array<IApplicationTokenAccess>, applicationQrCommands?: Array<IApplicationQrCommand>, pushTokens?: Array<PushToken>, userRoles?: Array<StringIdentityUserRole>, roles?: Array<IdentityRole>, roleClaims?: Array<StringIdentityRoleClaim>, users?: Array<ApplicationUser>, userClaims?: Array<StringIdentityUserClaim>, userLogins?: Array<StringIdentityUserLogin>, userTokens?: Array<StringIdentityUserToken>, databaseCurrentTransactionTransactionId?: string, databaseAutoTransactionsEnabled?: boolean, databaseProviderName?: string, changeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerLazyLoadingEnabled?: boolean, changeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId?: string, changeTrackerContextDatabaseAutoTransactionsEnabled?: boolean, changeTrackerContextDatabaseProviderName?: string, changeTrackerContextChangeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerContextChangeTrackerLazyLoadingEnabled?: boolean, changeTrackerContextChangeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextChangeTrackerContext?: DbContext, changeTrackerContextModel?: object, changeTrackerContextContextIdInstanceId?: string, changeTrackerContextContextIdLease?: number, model?: object, contextIdInstanceId?: string, contextIdLease?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userGetapptokenPost(cryptoCurrencies, orders, depositAddresses, userBalances, markets, tradingPairs, transactions, withdrawRequests, manualWithdrawRequests, trades, quotes, smsVerificationMessages, tradingAmounts, rippleDestinationTags, bitcoinBasedCurrencies, eRC20Tokens, balanceActions, keysValues, applicationTokenAccesses, applicationQrCommands, pushTokens, userRoles, roles, roleClaims, users, userClaims, userLogins, userTokens, databaseCurrentTransactionTransactionId, databaseAutoTransactionsEnabled, databaseProviderName, changeTrackerAutoDetectChangesEnabled, changeTrackerLazyLoadingEnabled, changeTrackerQueryTrackingBehavior, changeTrackerDeleteOrphansTiming, changeTrackerCascadeDeleteTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId, changeTrackerContextDatabaseAutoTransactionsEnabled, changeTrackerContextDatabaseProviderName, changeTrackerContextChangeTrackerAutoDetectChangesEnabled, changeTrackerContextChangeTrackerLazyLoadingEnabled, changeTrackerContextChangeTrackerQueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming, changeTrackerContextChangeTrackerContext, changeTrackerContextModel, changeTrackerContextContextIdInstanceId, changeTrackerContextContextIdLease, model, contextIdInstanceId, contextIdLease, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostGetReferrerEmailRequest} [postGetReferrerEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetreferreremailPost(postGetReferrerEmailRequest?: PostGetReferrerEmailRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userGetreferreremailPost(postGetReferrerEmailRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userResetpasswordPost(resetPassword?: ResetPassword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userResetpasswordPost(resetPassword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ForgotPassword} [forgotPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRestorepasswordPost(forgotPassword?: ForgotPassword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userRestorepasswordPost(forgotPassword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostSendSms} [postSendSms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSendsmscodePost(postSendSms?: PostSendSms, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userSendsmscodePost(postSendSms, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Array<CryptoCurrency>} [cryptoCurrencies] 
         * @param {Array<Order>} [orders] 
         * @param {Array<DepositAddress>} [depositAddresses] 
         * @param {Array<Balance>} [userBalances] 
         * @param {Array<Market>} [markets] 
         * @param {Array<TradingPair>} [tradingPairs] 
         * @param {Array<Transaction>} [transactions] 
         * @param {Array<WithdrawRequest>} [withdrawRequests] 
         * @param {Array<ManualWithdrawRequest>} [manualWithdrawRequests] 
         * @param {Array<Trade>} [trades] 
         * @param {Array<Quote>} [quotes] 
         * @param {Array<SmsVerificationMessage>} [smsVerificationMessages] 
         * @param {Array<TradingAmount>} [tradingAmounts] 
         * @param {Array<RippleDestinationTag>} [rippleDestinationTags] 
         * @param {Array<BitcoinBasedCurrency>} [bitcoinBasedCurrencies] 
         * @param {Array<ERC20Token>} [eRC20Tokens] 
         * @param {Array<BalanceAction>} [balanceActions] 
         * @param {Array<KeyValue>} [keysValues] 
         * @param {Array<IApplicationTokenAccess>} [applicationTokenAccesses] 
         * @param {Array<IApplicationQrCommand>} [applicationQrCommands] 
         * @param {Array<PushToken>} [pushTokens] 
         * @param {Array<StringIdentityUserRole>} [userRoles] 
         * @param {Array<IdentityRole>} [roles] 
         * @param {Array<StringIdentityRoleClaim>} [roleClaims] 
         * @param {Array<ApplicationUser>} [users] 
         * @param {Array<StringIdentityUserClaim>} [userClaims] 
         * @param {Array<StringIdentityUserLogin>} [userLogins] 
         * @param {Array<StringIdentityUserToken>} [userTokens] 
         * @param {string} [databaseCurrentTransactionTransactionId] 
         * @param {boolean} [databaseAutoTransactionsEnabled] 
         * @param {string} [databaseProviderName] 
         * @param {boolean} [changeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerCascadeDeleteTiming] 
         * @param {string} [changeTrackerContextDatabaseCurrentTransactionTransactionId] 
         * @param {boolean} [changeTrackerContextDatabaseAutoTransactionsEnabled] 
         * @param {string} [changeTrackerContextDatabaseProviderName] 
         * @param {boolean} [changeTrackerContextChangeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerContextChangeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerContextChangeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerCascadeDeleteTiming] 
         * @param {DbContext} [changeTrackerContextChangeTrackerContext] 
         * @param {object} [changeTrackerContextModel] 
         * @param {string} [changeTrackerContextContextIdInstanceId] 
         * @param {number} [changeTrackerContextContextIdLease] 
         * @param {object} [model] 
         * @param {string} [contextIdInstanceId] 
         * @param {number} [contextIdLease] 
         * @param {PostSetAffiliateRequest} [postSetAffiliateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSetAffiliatePost(cryptoCurrencies?: Array<CryptoCurrency>, orders?: Array<Order>, depositAddresses?: Array<DepositAddress>, userBalances?: Array<Balance>, markets?: Array<Market>, tradingPairs?: Array<TradingPair>, transactions?: Array<Transaction>, withdrawRequests?: Array<WithdrawRequest>, manualWithdrawRequests?: Array<ManualWithdrawRequest>, trades?: Array<Trade>, quotes?: Array<Quote>, smsVerificationMessages?: Array<SmsVerificationMessage>, tradingAmounts?: Array<TradingAmount>, rippleDestinationTags?: Array<RippleDestinationTag>, bitcoinBasedCurrencies?: Array<BitcoinBasedCurrency>, eRC20Tokens?: Array<ERC20Token>, balanceActions?: Array<BalanceAction>, keysValues?: Array<KeyValue>, applicationTokenAccesses?: Array<IApplicationTokenAccess>, applicationQrCommands?: Array<IApplicationQrCommand>, pushTokens?: Array<PushToken>, userRoles?: Array<StringIdentityUserRole>, roles?: Array<IdentityRole>, roleClaims?: Array<StringIdentityRoleClaim>, users?: Array<ApplicationUser>, userClaims?: Array<StringIdentityUserClaim>, userLogins?: Array<StringIdentityUserLogin>, userTokens?: Array<StringIdentityUserToken>, databaseCurrentTransactionTransactionId?: string, databaseAutoTransactionsEnabled?: boolean, databaseProviderName?: string, changeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerLazyLoadingEnabled?: boolean, changeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId?: string, changeTrackerContextDatabaseAutoTransactionsEnabled?: boolean, changeTrackerContextDatabaseProviderName?: string, changeTrackerContextChangeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerContextChangeTrackerLazyLoadingEnabled?: boolean, changeTrackerContextChangeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextChangeTrackerContext?: DbContext, changeTrackerContextModel?: object, changeTrackerContextContextIdInstanceId?: string, changeTrackerContextContextIdLease?: number, model?: object, contextIdInstanceId?: string, contextIdLease?: number, postSetAffiliateRequest?: PostSetAffiliateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userSetAffiliatePost(cryptoCurrencies, orders, depositAddresses, userBalances, markets, tradingPairs, transactions, withdrawRequests, manualWithdrawRequests, trades, quotes, smsVerificationMessages, tradingAmounts, rippleDestinationTags, bitcoinBasedCurrencies, eRC20Tokens, balanceActions, keysValues, applicationTokenAccesses, applicationQrCommands, pushTokens, userRoles, roles, roleClaims, users, userClaims, userLogins, userTokens, databaseCurrentTransactionTransactionId, databaseAutoTransactionsEnabled, databaseProviderName, changeTrackerAutoDetectChangesEnabled, changeTrackerLazyLoadingEnabled, changeTrackerQueryTrackingBehavior, changeTrackerDeleteOrphansTiming, changeTrackerCascadeDeleteTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId, changeTrackerContextDatabaseAutoTransactionsEnabled, changeTrackerContextDatabaseProviderName, changeTrackerContextChangeTrackerAutoDetectChangesEnabled, changeTrackerContextChangeTrackerLazyLoadingEnabled, changeTrackerContextChangeTrackerQueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming, changeTrackerContextChangeTrackerContext, changeTrackerContextModel, changeTrackerContextContextIdInstanceId, changeTrackerContextContextIdLease, model, contextIdInstanceId, contextIdLease, postSetAffiliateRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SignIn} [signIn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSigninPost(signIn?: SignIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userSigninPost(signIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SignUp} [signUp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSignupPost(signUp?: SignUp, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userSignupPost(signUp, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userValidatePinPost(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userValidatePinPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userVerificationsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userVerificationsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostVefirySms} [postVefirySms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userVerifysmscodePost(postVefirySms?: PostVefirySms, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userVerifysmscodePost(postVefirySms, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userWithdrawalsGet(currency?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userWithdrawalsGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserBalanceactionsGet(page?: number, size?: number, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUserBalanceactionsGet(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserBalancesGet(options?: any): AxiosPromise<{ [key: string]: number; }> {
            return UserApiFp(configuration).apiUserBalancesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserBalanceslistGet(options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUserBalanceslistGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserDepositsGet(currency?: string, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUserDepositsGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGetapptokenGet(options?: any): AxiosPromise<string> {
            return UserApiFp(configuration).apiUserGetapptokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserOrdersGet(pair?: string, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUserOrdersGet(pair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTradehistoryGet(page?: number, size?: number, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUserTradehistoryGet(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserValidateOauthGet(id?: string, options?: any): AxiosPromise<string> {
            return UserApiFp(configuration).apiUserValidateOauthGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserValidateapptokenPost(body?: object, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUserValidateapptokenPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserWithdrawalsGet(currency?: string, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUserWithdrawalsGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        user2faPost(body?: object, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).user2faPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<CryptoCurrency>} [cryptoCurrencies] 
         * @param {Array<Order>} [orders] 
         * @param {Array<DepositAddress>} [depositAddresses] 
         * @param {Array<Balance>} [userBalances] 
         * @param {Array<Market>} [markets] 
         * @param {Array<TradingPair>} [tradingPairs] 
         * @param {Array<Transaction>} [transactions] 
         * @param {Array<WithdrawRequest>} [withdrawRequests] 
         * @param {Array<ManualWithdrawRequest>} [manualWithdrawRequests] 
         * @param {Array<Trade>} [trades] 
         * @param {Array<Quote>} [quotes] 
         * @param {Array<SmsVerificationMessage>} [smsVerificationMessages] 
         * @param {Array<TradingAmount>} [tradingAmounts] 
         * @param {Array<RippleDestinationTag>} [rippleDestinationTags] 
         * @param {Array<BitcoinBasedCurrency>} [bitcoinBasedCurrencies] 
         * @param {Array<ERC20Token>} [eRC20Tokens] 
         * @param {Array<BalanceAction>} [balanceActions] 
         * @param {Array<KeyValue>} [keysValues] 
         * @param {Array<IApplicationTokenAccess>} [applicationTokenAccesses] 
         * @param {Array<IApplicationQrCommand>} [applicationQrCommands] 
         * @param {Array<PushToken>} [pushTokens] 
         * @param {Array<StringIdentityUserRole>} [userRoles] 
         * @param {Array<IdentityRole>} [roles] 
         * @param {Array<StringIdentityRoleClaim>} [roleClaims] 
         * @param {Array<ApplicationUser>} [users] 
         * @param {Array<StringIdentityUserClaim>} [userClaims] 
         * @param {Array<StringIdentityUserLogin>} [userLogins] 
         * @param {Array<StringIdentityUserToken>} [userTokens] 
         * @param {string} [databaseCurrentTransactionTransactionId] 
         * @param {boolean} [databaseAutoTransactionsEnabled] 
         * @param {string} [databaseProviderName] 
         * @param {boolean} [changeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerCascadeDeleteTiming] 
         * @param {string} [changeTrackerContextDatabaseCurrentTransactionTransactionId] 
         * @param {boolean} [changeTrackerContextDatabaseAutoTransactionsEnabled] 
         * @param {string} [changeTrackerContextDatabaseProviderName] 
         * @param {boolean} [changeTrackerContextChangeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerContextChangeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerContextChangeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerCascadeDeleteTiming] 
         * @param {DbContext} [changeTrackerContextChangeTrackerContext] 
         * @param {object} [changeTrackerContextModel] 
         * @param {string} [changeTrackerContextContextIdInstanceId] 
         * @param {number} [changeTrackerContextContextIdLease] 
         * @param {object} [model] 
         * @param {string} [contextIdInstanceId] 
         * @param {number} [contextIdLease] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAffiliatedataPost(cryptoCurrencies?: Array<CryptoCurrency>, orders?: Array<Order>, depositAddresses?: Array<DepositAddress>, userBalances?: Array<Balance>, markets?: Array<Market>, tradingPairs?: Array<TradingPair>, transactions?: Array<Transaction>, withdrawRequests?: Array<WithdrawRequest>, manualWithdrawRequests?: Array<ManualWithdrawRequest>, trades?: Array<Trade>, quotes?: Array<Quote>, smsVerificationMessages?: Array<SmsVerificationMessage>, tradingAmounts?: Array<TradingAmount>, rippleDestinationTags?: Array<RippleDestinationTag>, bitcoinBasedCurrencies?: Array<BitcoinBasedCurrency>, eRC20Tokens?: Array<ERC20Token>, balanceActions?: Array<BalanceAction>, keysValues?: Array<KeyValue>, applicationTokenAccesses?: Array<IApplicationTokenAccess>, applicationQrCommands?: Array<IApplicationQrCommand>, pushTokens?: Array<PushToken>, userRoles?: Array<StringIdentityUserRole>, roles?: Array<IdentityRole>, roleClaims?: Array<StringIdentityRoleClaim>, users?: Array<ApplicationUser>, userClaims?: Array<StringIdentityUserClaim>, userLogins?: Array<StringIdentityUserLogin>, userTokens?: Array<StringIdentityUserToken>, databaseCurrentTransactionTransactionId?: string, databaseAutoTransactionsEnabled?: boolean, databaseProviderName?: string, changeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerLazyLoadingEnabled?: boolean, changeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId?: string, changeTrackerContextDatabaseAutoTransactionsEnabled?: boolean, changeTrackerContextDatabaseProviderName?: string, changeTrackerContextChangeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerContextChangeTrackerLazyLoadingEnabled?: boolean, changeTrackerContextChangeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextChangeTrackerContext?: DbContext, changeTrackerContextModel?: object, changeTrackerContextContextIdInstanceId?: string, changeTrackerContextContextIdLease?: number, model?: object, contextIdInstanceId?: string, contextIdLease?: number, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userAffiliatedataPost(cryptoCurrencies, orders, depositAddresses, userBalances, markets, tradingPairs, transactions, withdrawRequests, manualWithdrawRequests, trades, quotes, smsVerificationMessages, tradingAmounts, rippleDestinationTags, bitcoinBasedCurrencies, eRC20Tokens, balanceActions, keysValues, applicationTokenAccesses, applicationQrCommands, pushTokens, userRoles, roles, roleClaims, users, userClaims, userLogins, userTokens, databaseCurrentTransactionTransactionId, databaseAutoTransactionsEnabled, databaseProviderName, changeTrackerAutoDetectChangesEnabled, changeTrackerLazyLoadingEnabled, changeTrackerQueryTrackingBehavior, changeTrackerDeleteOrphansTiming, changeTrackerCascadeDeleteTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId, changeTrackerContextDatabaseAutoTransactionsEnabled, changeTrackerContextDatabaseProviderName, changeTrackerContextChangeTrackerAutoDetectChangesEnabled, changeTrackerContextChangeTrackerLazyLoadingEnabled, changeTrackerContextChangeTrackerQueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming, changeTrackerContextChangeTrackerContext, changeTrackerContextModel, changeTrackerContextContextIdInstanceId, changeTrackerContextContextIdLease, model, contextIdInstanceId, contextIdLease, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApplicationqrcommandPost(body?: object, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userApplicationqrcommandPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [code] 
         * @param {boolean} [isInApp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userConfirmemailGet(userId?: string, code?: string, isInApp?: boolean, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userConfirmemailGet(userId, code, isInApp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EnableDisable2Fa} [enableDisable2Fa] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDisable2faPost(enableDisable2Fa?: EnableDisable2Fa, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userDisable2faPost(enableDisable2Fa, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EnableDisable2Fa} [enableDisable2Fa] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnable2faPost(enableDisable2Fa?: EnableDisable2Fa, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userEnable2faPost(enableDisable2Fa, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExternaltokenPost(body?: object, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userExternaltokenPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<CryptoCurrency>} [cryptoCurrencies] 
         * @param {Array<Order>} [orders] 
         * @param {Array<DepositAddress>} [depositAddresses] 
         * @param {Array<Balance>} [userBalances] 
         * @param {Array<Market>} [markets] 
         * @param {Array<TradingPair>} [tradingPairs] 
         * @param {Array<Transaction>} [transactions] 
         * @param {Array<WithdrawRequest>} [withdrawRequests] 
         * @param {Array<ManualWithdrawRequest>} [manualWithdrawRequests] 
         * @param {Array<Trade>} [trades] 
         * @param {Array<Quote>} [quotes] 
         * @param {Array<SmsVerificationMessage>} [smsVerificationMessages] 
         * @param {Array<TradingAmount>} [tradingAmounts] 
         * @param {Array<RippleDestinationTag>} [rippleDestinationTags] 
         * @param {Array<BitcoinBasedCurrency>} [bitcoinBasedCurrencies] 
         * @param {Array<ERC20Token>} [eRC20Tokens] 
         * @param {Array<BalanceAction>} [balanceActions] 
         * @param {Array<KeyValue>} [keysValues] 
         * @param {Array<IApplicationTokenAccess>} [applicationTokenAccesses] 
         * @param {Array<IApplicationQrCommand>} [applicationQrCommands] 
         * @param {Array<PushToken>} [pushTokens] 
         * @param {Array<StringIdentityUserRole>} [userRoles] 
         * @param {Array<IdentityRole>} [roles] 
         * @param {Array<StringIdentityRoleClaim>} [roleClaims] 
         * @param {Array<ApplicationUser>} [users] 
         * @param {Array<StringIdentityUserClaim>} [userClaims] 
         * @param {Array<StringIdentityUserLogin>} [userLogins] 
         * @param {Array<StringIdentityUserToken>} [userTokens] 
         * @param {string} [databaseCurrentTransactionTransactionId] 
         * @param {boolean} [databaseAutoTransactionsEnabled] 
         * @param {string} [databaseProviderName] 
         * @param {boolean} [changeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerCascadeDeleteTiming] 
         * @param {string} [changeTrackerContextDatabaseCurrentTransactionTransactionId] 
         * @param {boolean} [changeTrackerContextDatabaseAutoTransactionsEnabled] 
         * @param {string} [changeTrackerContextDatabaseProviderName] 
         * @param {boolean} [changeTrackerContextChangeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerContextChangeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerContextChangeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerCascadeDeleteTiming] 
         * @param {DbContext} [changeTrackerContextChangeTrackerContext] 
         * @param {object} [changeTrackerContextModel] 
         * @param {string} [changeTrackerContextContextIdInstanceId] 
         * @param {number} [changeTrackerContextContextIdLease] 
         * @param {object} [model] 
         * @param {string} [contextIdInstanceId] 
         * @param {number} [contextIdLease] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetapptokenPost(cryptoCurrencies?: Array<CryptoCurrency>, orders?: Array<Order>, depositAddresses?: Array<DepositAddress>, userBalances?: Array<Balance>, markets?: Array<Market>, tradingPairs?: Array<TradingPair>, transactions?: Array<Transaction>, withdrawRequests?: Array<WithdrawRequest>, manualWithdrawRequests?: Array<ManualWithdrawRequest>, trades?: Array<Trade>, quotes?: Array<Quote>, smsVerificationMessages?: Array<SmsVerificationMessage>, tradingAmounts?: Array<TradingAmount>, rippleDestinationTags?: Array<RippleDestinationTag>, bitcoinBasedCurrencies?: Array<BitcoinBasedCurrency>, eRC20Tokens?: Array<ERC20Token>, balanceActions?: Array<BalanceAction>, keysValues?: Array<KeyValue>, applicationTokenAccesses?: Array<IApplicationTokenAccess>, applicationQrCommands?: Array<IApplicationQrCommand>, pushTokens?: Array<PushToken>, userRoles?: Array<StringIdentityUserRole>, roles?: Array<IdentityRole>, roleClaims?: Array<StringIdentityRoleClaim>, users?: Array<ApplicationUser>, userClaims?: Array<StringIdentityUserClaim>, userLogins?: Array<StringIdentityUserLogin>, userTokens?: Array<StringIdentityUserToken>, databaseCurrentTransactionTransactionId?: string, databaseAutoTransactionsEnabled?: boolean, databaseProviderName?: string, changeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerLazyLoadingEnabled?: boolean, changeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId?: string, changeTrackerContextDatabaseAutoTransactionsEnabled?: boolean, changeTrackerContextDatabaseProviderName?: string, changeTrackerContextChangeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerContextChangeTrackerLazyLoadingEnabled?: boolean, changeTrackerContextChangeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextChangeTrackerContext?: DbContext, changeTrackerContextModel?: object, changeTrackerContextContextIdInstanceId?: string, changeTrackerContextContextIdLease?: number, model?: object, contextIdInstanceId?: string, contextIdLease?: number, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userGetapptokenPost(cryptoCurrencies, orders, depositAddresses, userBalances, markets, tradingPairs, transactions, withdrawRequests, manualWithdrawRequests, trades, quotes, smsVerificationMessages, tradingAmounts, rippleDestinationTags, bitcoinBasedCurrencies, eRC20Tokens, balanceActions, keysValues, applicationTokenAccesses, applicationQrCommands, pushTokens, userRoles, roles, roleClaims, users, userClaims, userLogins, userTokens, databaseCurrentTransactionTransactionId, databaseAutoTransactionsEnabled, databaseProviderName, changeTrackerAutoDetectChangesEnabled, changeTrackerLazyLoadingEnabled, changeTrackerQueryTrackingBehavior, changeTrackerDeleteOrphansTiming, changeTrackerCascadeDeleteTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId, changeTrackerContextDatabaseAutoTransactionsEnabled, changeTrackerContextDatabaseProviderName, changeTrackerContextChangeTrackerAutoDetectChangesEnabled, changeTrackerContextChangeTrackerLazyLoadingEnabled, changeTrackerContextChangeTrackerQueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming, changeTrackerContextChangeTrackerContext, changeTrackerContextModel, changeTrackerContextContextIdInstanceId, changeTrackerContextContextIdLease, model, contextIdInstanceId, contextIdLease, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostGetReferrerEmailRequest} [postGetReferrerEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetreferreremailPost(postGetReferrerEmailRequest?: PostGetReferrerEmailRequest, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userGetreferreremailPost(postGetReferrerEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userResetpasswordPost(resetPassword?: ResetPassword, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userResetpasswordPost(resetPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ForgotPassword} [forgotPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRestorepasswordPost(forgotPassword?: ForgotPassword, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userRestorepasswordPost(forgotPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostSendSms} [postSendSms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSendsmscodePost(postSendSms?: PostSendSms, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userSendsmscodePost(postSendSms, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<CryptoCurrency>} [cryptoCurrencies] 
         * @param {Array<Order>} [orders] 
         * @param {Array<DepositAddress>} [depositAddresses] 
         * @param {Array<Balance>} [userBalances] 
         * @param {Array<Market>} [markets] 
         * @param {Array<TradingPair>} [tradingPairs] 
         * @param {Array<Transaction>} [transactions] 
         * @param {Array<WithdrawRequest>} [withdrawRequests] 
         * @param {Array<ManualWithdrawRequest>} [manualWithdrawRequests] 
         * @param {Array<Trade>} [trades] 
         * @param {Array<Quote>} [quotes] 
         * @param {Array<SmsVerificationMessage>} [smsVerificationMessages] 
         * @param {Array<TradingAmount>} [tradingAmounts] 
         * @param {Array<RippleDestinationTag>} [rippleDestinationTags] 
         * @param {Array<BitcoinBasedCurrency>} [bitcoinBasedCurrencies] 
         * @param {Array<ERC20Token>} [eRC20Tokens] 
         * @param {Array<BalanceAction>} [balanceActions] 
         * @param {Array<KeyValue>} [keysValues] 
         * @param {Array<IApplicationTokenAccess>} [applicationTokenAccesses] 
         * @param {Array<IApplicationQrCommand>} [applicationQrCommands] 
         * @param {Array<PushToken>} [pushTokens] 
         * @param {Array<StringIdentityUserRole>} [userRoles] 
         * @param {Array<IdentityRole>} [roles] 
         * @param {Array<StringIdentityRoleClaim>} [roleClaims] 
         * @param {Array<ApplicationUser>} [users] 
         * @param {Array<StringIdentityUserClaim>} [userClaims] 
         * @param {Array<StringIdentityUserLogin>} [userLogins] 
         * @param {Array<StringIdentityUserToken>} [userTokens] 
         * @param {string} [databaseCurrentTransactionTransactionId] 
         * @param {boolean} [databaseAutoTransactionsEnabled] 
         * @param {string} [databaseProviderName] 
         * @param {boolean} [changeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerCascadeDeleteTiming] 
         * @param {string} [changeTrackerContextDatabaseCurrentTransactionTransactionId] 
         * @param {boolean} [changeTrackerContextDatabaseAutoTransactionsEnabled] 
         * @param {string} [changeTrackerContextDatabaseProviderName] 
         * @param {boolean} [changeTrackerContextChangeTrackerAutoDetectChangesEnabled] 
         * @param {boolean} [changeTrackerContextChangeTrackerLazyLoadingEnabled] 
         * @param {QueryTrackingBehavior} [changeTrackerContextChangeTrackerQueryTrackingBehavior] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerDeleteOrphansTiming] 
         * @param {CascadeTiming} [changeTrackerContextChangeTrackerCascadeDeleteTiming] 
         * @param {DbContext} [changeTrackerContextChangeTrackerContext] 
         * @param {object} [changeTrackerContextModel] 
         * @param {string} [changeTrackerContextContextIdInstanceId] 
         * @param {number} [changeTrackerContextContextIdLease] 
         * @param {object} [model] 
         * @param {string} [contextIdInstanceId] 
         * @param {number} [contextIdLease] 
         * @param {PostSetAffiliateRequest} [postSetAffiliateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSetAffiliatePost(cryptoCurrencies?: Array<CryptoCurrency>, orders?: Array<Order>, depositAddresses?: Array<DepositAddress>, userBalances?: Array<Balance>, markets?: Array<Market>, tradingPairs?: Array<TradingPair>, transactions?: Array<Transaction>, withdrawRequests?: Array<WithdrawRequest>, manualWithdrawRequests?: Array<ManualWithdrawRequest>, trades?: Array<Trade>, quotes?: Array<Quote>, smsVerificationMessages?: Array<SmsVerificationMessage>, tradingAmounts?: Array<TradingAmount>, rippleDestinationTags?: Array<RippleDestinationTag>, bitcoinBasedCurrencies?: Array<BitcoinBasedCurrency>, eRC20Tokens?: Array<ERC20Token>, balanceActions?: Array<BalanceAction>, keysValues?: Array<KeyValue>, applicationTokenAccesses?: Array<IApplicationTokenAccess>, applicationQrCommands?: Array<IApplicationQrCommand>, pushTokens?: Array<PushToken>, userRoles?: Array<StringIdentityUserRole>, roles?: Array<IdentityRole>, roleClaims?: Array<StringIdentityRoleClaim>, users?: Array<ApplicationUser>, userClaims?: Array<StringIdentityUserClaim>, userLogins?: Array<StringIdentityUserLogin>, userTokens?: Array<StringIdentityUserToken>, databaseCurrentTransactionTransactionId?: string, databaseAutoTransactionsEnabled?: boolean, databaseProviderName?: string, changeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerLazyLoadingEnabled?: boolean, changeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId?: string, changeTrackerContextDatabaseAutoTransactionsEnabled?: boolean, changeTrackerContextDatabaseProviderName?: string, changeTrackerContextChangeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerContextChangeTrackerLazyLoadingEnabled?: boolean, changeTrackerContextChangeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextChangeTrackerContext?: DbContext, changeTrackerContextModel?: object, changeTrackerContextContextIdInstanceId?: string, changeTrackerContextContextIdLease?: number, model?: object, contextIdInstanceId?: string, contextIdLease?: number, postSetAffiliateRequest?: PostSetAffiliateRequest, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userSetAffiliatePost(cryptoCurrencies, orders, depositAddresses, userBalances, markets, tradingPairs, transactions, withdrawRequests, manualWithdrawRequests, trades, quotes, smsVerificationMessages, tradingAmounts, rippleDestinationTags, bitcoinBasedCurrencies, eRC20Tokens, balanceActions, keysValues, applicationTokenAccesses, applicationQrCommands, pushTokens, userRoles, roles, roleClaims, users, userClaims, userLogins, userTokens, databaseCurrentTransactionTransactionId, databaseAutoTransactionsEnabled, databaseProviderName, changeTrackerAutoDetectChangesEnabled, changeTrackerLazyLoadingEnabled, changeTrackerQueryTrackingBehavior, changeTrackerDeleteOrphansTiming, changeTrackerCascadeDeleteTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId, changeTrackerContextDatabaseAutoTransactionsEnabled, changeTrackerContextDatabaseProviderName, changeTrackerContextChangeTrackerAutoDetectChangesEnabled, changeTrackerContextChangeTrackerLazyLoadingEnabled, changeTrackerContextChangeTrackerQueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming, changeTrackerContextChangeTrackerContext, changeTrackerContextModel, changeTrackerContextContextIdInstanceId, changeTrackerContextContextIdLease, model, contextIdInstanceId, contextIdLease, postSetAffiliateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignIn} [signIn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSigninPost(signIn?: SignIn, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userSigninPost(signIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUp} [signUp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSignupPost(signUp?: SignUp, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userSignupPost(signUp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userValidatePinPost(body?: object, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userValidatePinPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userVerificationsGet(options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userVerificationsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostVefirySms} [postVefirySms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userVerifysmscodePost(postVefirySms?: PostVefirySms, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userVerifysmscodePost(postVefirySms, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userWithdrawalsGet(currency?: string, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userWithdrawalsGet(currency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserBalanceactionsGet(page?: number, size?: number, options?: any) {
        return UserApiFp(this.configuration).apiUserBalanceactionsGet(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserBalancesGet(options?: any) {
        return UserApiFp(this.configuration).apiUserBalancesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserBalanceslistGet(options?: any) {
        return UserApiFp(this.configuration).apiUserBalanceslistGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [currency] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserDepositsGet(currency?: string, options?: any) {
        return UserApiFp(this.configuration).apiUserDepositsGet(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserGetapptokenGet(options?: any) {
        return UserApiFp(this.configuration).apiUserGetapptokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [pair] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserOrdersGet(pair?: string, options?: any) {
        return UserApiFp(this.configuration).apiUserOrdersGet(pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserTradehistoryGet(page?: number, size?: number, options?: any) {
        return UserApiFp(this.configuration).apiUserTradehistoryGet(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserValidateOauthGet(id?: string, options?: any) {
        return UserApiFp(this.configuration).apiUserValidateOauthGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserValidateapptokenPost(body?: object, options?: any) {
        return UserApiFp(this.configuration).apiUserValidateapptokenPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [currency] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserWithdrawalsGet(currency?: string, options?: any) {
        return UserApiFp(this.configuration).apiUserWithdrawalsGet(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public user2faPost(body?: object, options?: any) {
        return UserApiFp(this.configuration).user2faPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<CryptoCurrency>} [cryptoCurrencies] 
     * @param {Array<Order>} [orders] 
     * @param {Array<DepositAddress>} [depositAddresses] 
     * @param {Array<Balance>} [userBalances] 
     * @param {Array<Market>} [markets] 
     * @param {Array<TradingPair>} [tradingPairs] 
     * @param {Array<Transaction>} [transactions] 
     * @param {Array<WithdrawRequest>} [withdrawRequests] 
     * @param {Array<ManualWithdrawRequest>} [manualWithdrawRequests] 
     * @param {Array<Trade>} [trades] 
     * @param {Array<Quote>} [quotes] 
     * @param {Array<SmsVerificationMessage>} [smsVerificationMessages] 
     * @param {Array<TradingAmount>} [tradingAmounts] 
     * @param {Array<RippleDestinationTag>} [rippleDestinationTags] 
     * @param {Array<BitcoinBasedCurrency>} [bitcoinBasedCurrencies] 
     * @param {Array<ERC20Token>} [eRC20Tokens] 
     * @param {Array<BalanceAction>} [balanceActions] 
     * @param {Array<KeyValue>} [keysValues] 
     * @param {Array<IApplicationTokenAccess>} [applicationTokenAccesses] 
     * @param {Array<IApplicationQrCommand>} [applicationQrCommands] 
     * @param {Array<PushToken>} [pushTokens] 
     * @param {Array<StringIdentityUserRole>} [userRoles] 
     * @param {Array<IdentityRole>} [roles] 
     * @param {Array<StringIdentityRoleClaim>} [roleClaims] 
     * @param {Array<ApplicationUser>} [users] 
     * @param {Array<StringIdentityUserClaim>} [userClaims] 
     * @param {Array<StringIdentityUserLogin>} [userLogins] 
     * @param {Array<StringIdentityUserToken>} [userTokens] 
     * @param {string} [databaseCurrentTransactionTransactionId] 
     * @param {boolean} [databaseAutoTransactionsEnabled] 
     * @param {string} [databaseProviderName] 
     * @param {boolean} [changeTrackerAutoDetectChangesEnabled] 
     * @param {boolean} [changeTrackerLazyLoadingEnabled] 
     * @param {QueryTrackingBehavior} [changeTrackerQueryTrackingBehavior] 
     * @param {CascadeTiming} [changeTrackerDeleteOrphansTiming] 
     * @param {CascadeTiming} [changeTrackerCascadeDeleteTiming] 
     * @param {string} [changeTrackerContextDatabaseCurrentTransactionTransactionId] 
     * @param {boolean} [changeTrackerContextDatabaseAutoTransactionsEnabled] 
     * @param {string} [changeTrackerContextDatabaseProviderName] 
     * @param {boolean} [changeTrackerContextChangeTrackerAutoDetectChangesEnabled] 
     * @param {boolean} [changeTrackerContextChangeTrackerLazyLoadingEnabled] 
     * @param {QueryTrackingBehavior} [changeTrackerContextChangeTrackerQueryTrackingBehavior] 
     * @param {CascadeTiming} [changeTrackerContextChangeTrackerDeleteOrphansTiming] 
     * @param {CascadeTiming} [changeTrackerContextChangeTrackerCascadeDeleteTiming] 
     * @param {DbContext} [changeTrackerContextChangeTrackerContext] 
     * @param {object} [changeTrackerContextModel] 
     * @param {string} [changeTrackerContextContextIdInstanceId] 
     * @param {number} [changeTrackerContextContextIdLease] 
     * @param {object} [model] 
     * @param {string} [contextIdInstanceId] 
     * @param {number} [contextIdLease] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userAffiliatedataPost(cryptoCurrencies?: Array<CryptoCurrency>, orders?: Array<Order>, depositAddresses?: Array<DepositAddress>, userBalances?: Array<Balance>, markets?: Array<Market>, tradingPairs?: Array<TradingPair>, transactions?: Array<Transaction>, withdrawRequests?: Array<WithdrawRequest>, manualWithdrawRequests?: Array<ManualWithdrawRequest>, trades?: Array<Trade>, quotes?: Array<Quote>, smsVerificationMessages?: Array<SmsVerificationMessage>, tradingAmounts?: Array<TradingAmount>, rippleDestinationTags?: Array<RippleDestinationTag>, bitcoinBasedCurrencies?: Array<BitcoinBasedCurrency>, eRC20Tokens?: Array<ERC20Token>, balanceActions?: Array<BalanceAction>, keysValues?: Array<KeyValue>, applicationTokenAccesses?: Array<IApplicationTokenAccess>, applicationQrCommands?: Array<IApplicationQrCommand>, pushTokens?: Array<PushToken>, userRoles?: Array<StringIdentityUserRole>, roles?: Array<IdentityRole>, roleClaims?: Array<StringIdentityRoleClaim>, users?: Array<ApplicationUser>, userClaims?: Array<StringIdentityUserClaim>, userLogins?: Array<StringIdentityUserLogin>, userTokens?: Array<StringIdentityUserToken>, databaseCurrentTransactionTransactionId?: string, databaseAutoTransactionsEnabled?: boolean, databaseProviderName?: string, changeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerLazyLoadingEnabled?: boolean, changeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId?: string, changeTrackerContextDatabaseAutoTransactionsEnabled?: boolean, changeTrackerContextDatabaseProviderName?: string, changeTrackerContextChangeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerContextChangeTrackerLazyLoadingEnabled?: boolean, changeTrackerContextChangeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextChangeTrackerContext?: DbContext, changeTrackerContextModel?: object, changeTrackerContextContextIdInstanceId?: string, changeTrackerContextContextIdLease?: number, model?: object, contextIdInstanceId?: string, contextIdLease?: number, options?: any) {
        return UserApiFp(this.configuration).userAffiliatedataPost(cryptoCurrencies, orders, depositAddresses, userBalances, markets, tradingPairs, transactions, withdrawRequests, manualWithdrawRequests, trades, quotes, smsVerificationMessages, tradingAmounts, rippleDestinationTags, bitcoinBasedCurrencies, eRC20Tokens, balanceActions, keysValues, applicationTokenAccesses, applicationQrCommands, pushTokens, userRoles, roles, roleClaims, users, userClaims, userLogins, userTokens, databaseCurrentTransactionTransactionId, databaseAutoTransactionsEnabled, databaseProviderName, changeTrackerAutoDetectChangesEnabled, changeTrackerLazyLoadingEnabled, changeTrackerQueryTrackingBehavior, changeTrackerDeleteOrphansTiming, changeTrackerCascadeDeleteTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId, changeTrackerContextDatabaseAutoTransactionsEnabled, changeTrackerContextDatabaseProviderName, changeTrackerContextChangeTrackerAutoDetectChangesEnabled, changeTrackerContextChangeTrackerLazyLoadingEnabled, changeTrackerContextChangeTrackerQueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming, changeTrackerContextChangeTrackerContext, changeTrackerContextModel, changeTrackerContextContextIdInstanceId, changeTrackerContextContextIdLease, model, contextIdInstanceId, contextIdLease, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userApplicationqrcommandPost(body?: object, options?: any) {
        return UserApiFp(this.configuration).userApplicationqrcommandPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {string} [code] 
     * @param {boolean} [isInApp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userConfirmemailGet(userId?: string, code?: string, isInApp?: boolean, options?: any) {
        return UserApiFp(this.configuration).userConfirmemailGet(userId, code, isInApp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EnableDisable2Fa} [enableDisable2Fa] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDisable2faPost(enableDisable2Fa?: EnableDisable2Fa, options?: any) {
        return UserApiFp(this.configuration).userDisable2faPost(enableDisable2Fa, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EnableDisable2Fa} [enableDisable2Fa] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userEnable2faPost(enableDisable2Fa?: EnableDisable2Fa, options?: any) {
        return UserApiFp(this.configuration).userEnable2faPost(enableDisable2Fa, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userExternaltokenPost(body?: object, options?: any) {
        return UserApiFp(this.configuration).userExternaltokenPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<CryptoCurrency>} [cryptoCurrencies] 
     * @param {Array<Order>} [orders] 
     * @param {Array<DepositAddress>} [depositAddresses] 
     * @param {Array<Balance>} [userBalances] 
     * @param {Array<Market>} [markets] 
     * @param {Array<TradingPair>} [tradingPairs] 
     * @param {Array<Transaction>} [transactions] 
     * @param {Array<WithdrawRequest>} [withdrawRequests] 
     * @param {Array<ManualWithdrawRequest>} [manualWithdrawRequests] 
     * @param {Array<Trade>} [trades] 
     * @param {Array<Quote>} [quotes] 
     * @param {Array<SmsVerificationMessage>} [smsVerificationMessages] 
     * @param {Array<TradingAmount>} [tradingAmounts] 
     * @param {Array<RippleDestinationTag>} [rippleDestinationTags] 
     * @param {Array<BitcoinBasedCurrency>} [bitcoinBasedCurrencies] 
     * @param {Array<ERC20Token>} [eRC20Tokens] 
     * @param {Array<BalanceAction>} [balanceActions] 
     * @param {Array<KeyValue>} [keysValues] 
     * @param {Array<IApplicationTokenAccess>} [applicationTokenAccesses] 
     * @param {Array<IApplicationQrCommand>} [applicationQrCommands] 
     * @param {Array<PushToken>} [pushTokens] 
     * @param {Array<StringIdentityUserRole>} [userRoles] 
     * @param {Array<IdentityRole>} [roles] 
     * @param {Array<StringIdentityRoleClaim>} [roleClaims] 
     * @param {Array<ApplicationUser>} [users] 
     * @param {Array<StringIdentityUserClaim>} [userClaims] 
     * @param {Array<StringIdentityUserLogin>} [userLogins] 
     * @param {Array<StringIdentityUserToken>} [userTokens] 
     * @param {string} [databaseCurrentTransactionTransactionId] 
     * @param {boolean} [databaseAutoTransactionsEnabled] 
     * @param {string} [databaseProviderName] 
     * @param {boolean} [changeTrackerAutoDetectChangesEnabled] 
     * @param {boolean} [changeTrackerLazyLoadingEnabled] 
     * @param {QueryTrackingBehavior} [changeTrackerQueryTrackingBehavior] 
     * @param {CascadeTiming} [changeTrackerDeleteOrphansTiming] 
     * @param {CascadeTiming} [changeTrackerCascadeDeleteTiming] 
     * @param {string} [changeTrackerContextDatabaseCurrentTransactionTransactionId] 
     * @param {boolean} [changeTrackerContextDatabaseAutoTransactionsEnabled] 
     * @param {string} [changeTrackerContextDatabaseProviderName] 
     * @param {boolean} [changeTrackerContextChangeTrackerAutoDetectChangesEnabled] 
     * @param {boolean} [changeTrackerContextChangeTrackerLazyLoadingEnabled] 
     * @param {QueryTrackingBehavior} [changeTrackerContextChangeTrackerQueryTrackingBehavior] 
     * @param {CascadeTiming} [changeTrackerContextChangeTrackerDeleteOrphansTiming] 
     * @param {CascadeTiming} [changeTrackerContextChangeTrackerCascadeDeleteTiming] 
     * @param {DbContext} [changeTrackerContextChangeTrackerContext] 
     * @param {object} [changeTrackerContextModel] 
     * @param {string} [changeTrackerContextContextIdInstanceId] 
     * @param {number} [changeTrackerContextContextIdLease] 
     * @param {object} [model] 
     * @param {string} [contextIdInstanceId] 
     * @param {number} [contextIdLease] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetapptokenPost(cryptoCurrencies?: Array<CryptoCurrency>, orders?: Array<Order>, depositAddresses?: Array<DepositAddress>, userBalances?: Array<Balance>, markets?: Array<Market>, tradingPairs?: Array<TradingPair>, transactions?: Array<Transaction>, withdrawRequests?: Array<WithdrawRequest>, manualWithdrawRequests?: Array<ManualWithdrawRequest>, trades?: Array<Trade>, quotes?: Array<Quote>, smsVerificationMessages?: Array<SmsVerificationMessage>, tradingAmounts?: Array<TradingAmount>, rippleDestinationTags?: Array<RippleDestinationTag>, bitcoinBasedCurrencies?: Array<BitcoinBasedCurrency>, eRC20Tokens?: Array<ERC20Token>, balanceActions?: Array<BalanceAction>, keysValues?: Array<KeyValue>, applicationTokenAccesses?: Array<IApplicationTokenAccess>, applicationQrCommands?: Array<IApplicationQrCommand>, pushTokens?: Array<PushToken>, userRoles?: Array<StringIdentityUserRole>, roles?: Array<IdentityRole>, roleClaims?: Array<StringIdentityRoleClaim>, users?: Array<ApplicationUser>, userClaims?: Array<StringIdentityUserClaim>, userLogins?: Array<StringIdentityUserLogin>, userTokens?: Array<StringIdentityUserToken>, databaseCurrentTransactionTransactionId?: string, databaseAutoTransactionsEnabled?: boolean, databaseProviderName?: string, changeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerLazyLoadingEnabled?: boolean, changeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId?: string, changeTrackerContextDatabaseAutoTransactionsEnabled?: boolean, changeTrackerContextDatabaseProviderName?: string, changeTrackerContextChangeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerContextChangeTrackerLazyLoadingEnabled?: boolean, changeTrackerContextChangeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextChangeTrackerContext?: DbContext, changeTrackerContextModel?: object, changeTrackerContextContextIdInstanceId?: string, changeTrackerContextContextIdLease?: number, model?: object, contextIdInstanceId?: string, contextIdLease?: number, options?: any) {
        return UserApiFp(this.configuration).userGetapptokenPost(cryptoCurrencies, orders, depositAddresses, userBalances, markets, tradingPairs, transactions, withdrawRequests, manualWithdrawRequests, trades, quotes, smsVerificationMessages, tradingAmounts, rippleDestinationTags, bitcoinBasedCurrencies, eRC20Tokens, balanceActions, keysValues, applicationTokenAccesses, applicationQrCommands, pushTokens, userRoles, roles, roleClaims, users, userClaims, userLogins, userTokens, databaseCurrentTransactionTransactionId, databaseAutoTransactionsEnabled, databaseProviderName, changeTrackerAutoDetectChangesEnabled, changeTrackerLazyLoadingEnabled, changeTrackerQueryTrackingBehavior, changeTrackerDeleteOrphansTiming, changeTrackerCascadeDeleteTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId, changeTrackerContextDatabaseAutoTransactionsEnabled, changeTrackerContextDatabaseProviderName, changeTrackerContextChangeTrackerAutoDetectChangesEnabled, changeTrackerContextChangeTrackerLazyLoadingEnabled, changeTrackerContextChangeTrackerQueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming, changeTrackerContextChangeTrackerContext, changeTrackerContextModel, changeTrackerContextContextIdInstanceId, changeTrackerContextContextIdLease, model, contextIdInstanceId, contextIdLease, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostGetReferrerEmailRequest} [postGetReferrerEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetreferreremailPost(postGetReferrerEmailRequest?: PostGetReferrerEmailRequest, options?: any) {
        return UserApiFp(this.configuration).userGetreferreremailPost(postGetReferrerEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ResetPassword} [resetPassword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userResetpasswordPost(resetPassword?: ResetPassword, options?: any) {
        return UserApiFp(this.configuration).userResetpasswordPost(resetPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ForgotPassword} [forgotPassword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userRestorepasswordPost(forgotPassword?: ForgotPassword, options?: any) {
        return UserApiFp(this.configuration).userRestorepasswordPost(forgotPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostSendSms} [postSendSms] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSendsmscodePost(postSendSms?: PostSendSms, options?: any) {
        return UserApiFp(this.configuration).userSendsmscodePost(postSendSms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<CryptoCurrency>} [cryptoCurrencies] 
     * @param {Array<Order>} [orders] 
     * @param {Array<DepositAddress>} [depositAddresses] 
     * @param {Array<Balance>} [userBalances] 
     * @param {Array<Market>} [markets] 
     * @param {Array<TradingPair>} [tradingPairs] 
     * @param {Array<Transaction>} [transactions] 
     * @param {Array<WithdrawRequest>} [withdrawRequests] 
     * @param {Array<ManualWithdrawRequest>} [manualWithdrawRequests] 
     * @param {Array<Trade>} [trades] 
     * @param {Array<Quote>} [quotes] 
     * @param {Array<SmsVerificationMessage>} [smsVerificationMessages] 
     * @param {Array<TradingAmount>} [tradingAmounts] 
     * @param {Array<RippleDestinationTag>} [rippleDestinationTags] 
     * @param {Array<BitcoinBasedCurrency>} [bitcoinBasedCurrencies] 
     * @param {Array<ERC20Token>} [eRC20Tokens] 
     * @param {Array<BalanceAction>} [balanceActions] 
     * @param {Array<KeyValue>} [keysValues] 
     * @param {Array<IApplicationTokenAccess>} [applicationTokenAccesses] 
     * @param {Array<IApplicationQrCommand>} [applicationQrCommands] 
     * @param {Array<PushToken>} [pushTokens] 
     * @param {Array<StringIdentityUserRole>} [userRoles] 
     * @param {Array<IdentityRole>} [roles] 
     * @param {Array<StringIdentityRoleClaim>} [roleClaims] 
     * @param {Array<ApplicationUser>} [users] 
     * @param {Array<StringIdentityUserClaim>} [userClaims] 
     * @param {Array<StringIdentityUserLogin>} [userLogins] 
     * @param {Array<StringIdentityUserToken>} [userTokens] 
     * @param {string} [databaseCurrentTransactionTransactionId] 
     * @param {boolean} [databaseAutoTransactionsEnabled] 
     * @param {string} [databaseProviderName] 
     * @param {boolean} [changeTrackerAutoDetectChangesEnabled] 
     * @param {boolean} [changeTrackerLazyLoadingEnabled] 
     * @param {QueryTrackingBehavior} [changeTrackerQueryTrackingBehavior] 
     * @param {CascadeTiming} [changeTrackerDeleteOrphansTiming] 
     * @param {CascadeTiming} [changeTrackerCascadeDeleteTiming] 
     * @param {string} [changeTrackerContextDatabaseCurrentTransactionTransactionId] 
     * @param {boolean} [changeTrackerContextDatabaseAutoTransactionsEnabled] 
     * @param {string} [changeTrackerContextDatabaseProviderName] 
     * @param {boolean} [changeTrackerContextChangeTrackerAutoDetectChangesEnabled] 
     * @param {boolean} [changeTrackerContextChangeTrackerLazyLoadingEnabled] 
     * @param {QueryTrackingBehavior} [changeTrackerContextChangeTrackerQueryTrackingBehavior] 
     * @param {CascadeTiming} [changeTrackerContextChangeTrackerDeleteOrphansTiming] 
     * @param {CascadeTiming} [changeTrackerContextChangeTrackerCascadeDeleteTiming] 
     * @param {DbContext} [changeTrackerContextChangeTrackerContext] 
     * @param {object} [changeTrackerContextModel] 
     * @param {string} [changeTrackerContextContextIdInstanceId] 
     * @param {number} [changeTrackerContextContextIdLease] 
     * @param {object} [model] 
     * @param {string} [contextIdInstanceId] 
     * @param {number} [contextIdLease] 
     * @param {PostSetAffiliateRequest} [postSetAffiliateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSetAffiliatePost(cryptoCurrencies?: Array<CryptoCurrency>, orders?: Array<Order>, depositAddresses?: Array<DepositAddress>, userBalances?: Array<Balance>, markets?: Array<Market>, tradingPairs?: Array<TradingPair>, transactions?: Array<Transaction>, withdrawRequests?: Array<WithdrawRequest>, manualWithdrawRequests?: Array<ManualWithdrawRequest>, trades?: Array<Trade>, quotes?: Array<Quote>, smsVerificationMessages?: Array<SmsVerificationMessage>, tradingAmounts?: Array<TradingAmount>, rippleDestinationTags?: Array<RippleDestinationTag>, bitcoinBasedCurrencies?: Array<BitcoinBasedCurrency>, eRC20Tokens?: Array<ERC20Token>, balanceActions?: Array<BalanceAction>, keysValues?: Array<KeyValue>, applicationTokenAccesses?: Array<IApplicationTokenAccess>, applicationQrCommands?: Array<IApplicationQrCommand>, pushTokens?: Array<PushToken>, userRoles?: Array<StringIdentityUserRole>, roles?: Array<IdentityRole>, roleClaims?: Array<StringIdentityRoleClaim>, users?: Array<ApplicationUser>, userClaims?: Array<StringIdentityUserClaim>, userLogins?: Array<StringIdentityUserLogin>, userTokens?: Array<StringIdentityUserToken>, databaseCurrentTransactionTransactionId?: string, databaseAutoTransactionsEnabled?: boolean, databaseProviderName?: string, changeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerLazyLoadingEnabled?: boolean, changeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId?: string, changeTrackerContextDatabaseAutoTransactionsEnabled?: boolean, changeTrackerContextDatabaseProviderName?: string, changeTrackerContextChangeTrackerAutoDetectChangesEnabled?: boolean, changeTrackerContextChangeTrackerLazyLoadingEnabled?: boolean, changeTrackerContextChangeTrackerQueryTrackingBehavior?: QueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming?: CascadeTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming?: CascadeTiming, changeTrackerContextChangeTrackerContext?: DbContext, changeTrackerContextModel?: object, changeTrackerContextContextIdInstanceId?: string, changeTrackerContextContextIdLease?: number, model?: object, contextIdInstanceId?: string, contextIdLease?: number, postSetAffiliateRequest?: PostSetAffiliateRequest, options?: any) {
        return UserApiFp(this.configuration).userSetAffiliatePost(cryptoCurrencies, orders, depositAddresses, userBalances, markets, tradingPairs, transactions, withdrawRequests, manualWithdrawRequests, trades, quotes, smsVerificationMessages, tradingAmounts, rippleDestinationTags, bitcoinBasedCurrencies, eRC20Tokens, balanceActions, keysValues, applicationTokenAccesses, applicationQrCommands, pushTokens, userRoles, roles, roleClaims, users, userClaims, userLogins, userTokens, databaseCurrentTransactionTransactionId, databaseAutoTransactionsEnabled, databaseProviderName, changeTrackerAutoDetectChangesEnabled, changeTrackerLazyLoadingEnabled, changeTrackerQueryTrackingBehavior, changeTrackerDeleteOrphansTiming, changeTrackerCascadeDeleteTiming, changeTrackerContextDatabaseCurrentTransactionTransactionId, changeTrackerContextDatabaseAutoTransactionsEnabled, changeTrackerContextDatabaseProviderName, changeTrackerContextChangeTrackerAutoDetectChangesEnabled, changeTrackerContextChangeTrackerLazyLoadingEnabled, changeTrackerContextChangeTrackerQueryTrackingBehavior, changeTrackerContextChangeTrackerDeleteOrphansTiming, changeTrackerContextChangeTrackerCascadeDeleteTiming, changeTrackerContextChangeTrackerContext, changeTrackerContextModel, changeTrackerContextContextIdInstanceId, changeTrackerContextContextIdLease, model, contextIdInstanceId, contextIdLease, postSetAffiliateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignIn} [signIn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSigninPost(signIn?: SignIn, options?: any) {
        return UserApiFp(this.configuration).userSigninPost(signIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUp} [signUp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSignupPost(signUp?: SignUp, options?: any) {
        return UserApiFp(this.configuration).userSignupPost(signUp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userValidatePinPost(body?: object, options?: any) {
        return UserApiFp(this.configuration).userValidatePinPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userVerificationsGet(options?: any) {
        return UserApiFp(this.configuration).userVerificationsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostVefirySms} [postVefirySms] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userVerifysmscodePost(postVefirySms?: PostVefirySms, options?: any) {
        return UserApiFp(this.configuration).userVerifysmscodePost(postVefirySms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [currency] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userWithdrawalsGet(currency?: string, options?: any) {
        return UserApiFp(this.configuration).userWithdrawalsGet(currency, options).then((request) => request(this.axios, this.basePath));
    }

}


